defMultiProcErrorHandler <- function(cmd, exitStatus, ...)
{
    stop(sprintf("Failed to run command '%s' with args: '%s'. Exit code: %d",
                 cmd$command, paste0(cmd$args, collapse = " "), exitStatus))
}

#' Simultaneous execution of system commands.
#'
#' Execute a queue of system commands in parallel.
#'
#' This function executes a given queue with system commands in parallel to
#' speed up computation. Commands are executed in the background using the
#' \pkg{processx} package. A configurable maximum amount of processes are
#' created to execute multiple commands in parallel.
#'
#' Multiple commands may be executed in sequence that are launched from a single
#' parent process (as part of a batch script on Windows or combined with the
#' shell AND operator otherwise). Note that in this scenario still multiple
#' processes are spawned. Each of these processes will manage a chunk of the
#' command queue (size defined by \code{batchSize} argument). This approach is
#' typically suitable for fast running commands: the overhead of spawning a new
#' process for each command from R would in this case be significant enough to
#' loose most of the speedup otherwise gained with parallel execution. Note that
#' the actual batch size may be adjusted to ensure that a maximum number of
#' processes are running simultaneously.
#'
#' Other functionalities of this function include timeout and error handling.
#'
#' @param commandQueue A list with commands. Should contain \code{command}
#'   (scalar string) and \code{args} (\code{character} vector). More user
#'   defineds fields are allowed and useful to attach command information that
#'   can be used in the finish, timeout and error handlers.
#' @param finishHandler A function that is called when a command has finished.
#'   This function is typically used to process any results generated by the
#'   command. The function is called right after spawning a new process, hence
#'   processing results can occur while the next command is running in the
#'   background. The function signature should be \code{function(cmd)} where
#'   \code{cmd} is the queue data (from \code{commandQueue}) of the command that
#'   has finished.
#' @param timeoutHandler A function that is called whenever a timeout for a
#'   command occurs. Should return \code{TRUE} if execution of the command
#'   should be retried. The function signature should be \code{function(cmd,
#'   retries)} where \code{cmd} is the queue data for that command and
#'   \code{retries} the number of times the command has been retried.
#' @param errorHandler Similar to \code{timeoutHandler}, but called whenever a
#'   command has failed. The signature should be \code{function(cmd, exitStatus,
#'   retries)}. The \code{exitStatus} argument is the exit code of the command
#'   (may be \code{NA} in rare cases this is unknown). Other arguments are as
#'   \code{timeoutHandler}.
#' @param procTimeout The maximum time a process may consume before a timeout
#'   occurs (in seconds). Set to \code{NULL} to disable
#'   timeouts.
#' @param printOutput,printError Set to \code{TRUE} to print stdout/stderr
#'   output to the console. Currently unused and untested.
#' @param showProgress Set to \code{TRUE} to display a progress bar.
#' @param waitTimeout Number of milliseconds to wait before checking if a new
#'   process should be spawned.
#' @param batchSize Number of commands that should be executed in sequence per
#'   processes. See details.
#' @param delayBetweenProc Minimum number of milliseconds to wait before
#'   spawning a new process. Might be needed to workaround errors.
#'
#' @keywords internal
executeMultiProcess <- function(commandQueue, finishHandler,
                                timeoutHandler = function(...) TRUE,
                                errorHandler = defMultiProcErrorHandler,
                                prepareHandler = NULL,
                                procTimeout = NULL, printOutput = FALSE, printError = FALSE,
                                showProgress = TRUE, waitTimeout = 50,
                                batchSize = 1, delayBetweenProc = 0)
{
    # UNDONE
    return(executeMultiProcessClassic(commandQueue, finishHandler,
                                      timeoutHandler,
                                      errorHandler,
                                      prepareHandler,
                                      procTimeout, printOutput, printError,
                                      showProgress, waitTimeout,
                                      batchSize, delayBetweenProc))
    
    if (length(commandQueue) == 0)
        return(list())

    runningProcs <- vector("list", maxProcAmount)
    runningProcInfo <- vector("list", maxProcAmount)
    
    if (!is.null(prepareHandler))
        commandQueue <- lapply(commandQueue, prepareHandler)
    
    totCmdCount <- length(commandQueue)

    ret <- vector("list", totCmdCount)
    names(ret) <- names(commandQueue)

    if (showProgress)
        prog <- openProgBar(0, totCmdCount)

    nextCommand <- 1
    finishedCommands <- 0
    lastCommandTime <- 0 # at which time (in ms) the last command was started

    doLog <- any(sapply(commandQueue, function(q) !is.null(q$logFile)))
    stopifnot(batchSize == 1 || (!doLog && !printOutput && !printError))

    # clear up stale processes: see https://github.com/r-lib/processx/issues/171
    on.exit({
        for (pi in seq_along(runningProcs))
        {
            if (!is.null(runningProcs[[pi]]) && runningProcInfo[[pi]]$running)
                runningProcs[[pi]]$kill()
        }

        if (doLog)
        {
            for (cmd in commandQueue)
            {
                if (!is.null(cmd$logFile))
                {
                    tryCatch({
                        fprintf(cmd$logFile, "command: %s\nargs: %s\n", cmd$command, paste0(cmd$args, collapse = " "))
                        fprintf(cmd$logFile, "\n---\n\noutput:\n%s\n\nstandard error output:\n%s\n",
                                cmd$stdoutLog, cmd$stderrLog, append = TRUE)
                    }, error = function(e) "")
                }
            }
        }
    }, add = TRUE)

    sucDir <- tempfile("suc")
    dir.create(sucDir)

    procFinished <- function(pi) !is.null(runningProcs[[pi]]) && !runningProcs[[pi]]$is_alive() && runningProcInfo[[pi]]$running

    doProcessOut <- function(txt, print)
    {
        if (print)
            cat(txt)
        if (doLog)
            return(txt)
    }
    
    # reading process output might fail sometimes(?)
    emptyStrOnErr <- function(expr) tryCatch(expr, error = function(e) "")
    
    while (nextCommand <= totCmdCount || any(sapply(runningProcInfo, function(rp) !is.null(rp) && rp$running)))
    {
        for (pi in seq_along(runningProcs))
        {
            finishedRunning <- procFinished(pi)

            if (!is.null(runningProcs[[pi]]))
            {
                cmdInds <- seq(runningProcInfo[[pi]]$cmdIndRange[1], runningProcInfo[[pi]]$cmdIndRange[2])

                # NOTE: logging/printing currently doesn't work in batch mode
                if (printOutput || printError || doLog)
                {
                    cind <- runningProcInfo[[pi]]$cmdIndRange[1]
                    commandQueue[[cind]]$stdoutLog <- paste0(commandQueue[[cind]]$stdoutLog,
                                                             emptyStrOnErr(doProcessOut(rp[[pi]]$read_output(), printOutput)))
                    commandQueue[[cind]]$stderrLog <- paste0(commandQueue[[cind]]$stderrLog,
                                                             emptyStrOnErr(doProcessOut(rp[[pi]]$read_error(), printError)))
                }
            }

            if (finishedRunning)
            {
                ncmd <- length(cmdInds)

                # NOTE: as per docs get_exit_status() might return NA, in this
                # case check if a command failed (by checking for missing
                # success marker files)
                # UNDONE: when batchSize=1 we don't create/check success
                # markers. Fix this? So far never had NA exit statuses in that
                # situation.
                exitStatus <- runningProcs[[pi]]$get_exit_status()

                if (is.na(exitStatus) || exitStatus != 0) # something (may have) failed?
                {
                    maybe <- maybeRestartCommand(commandQueue[cmdInds], runningProcInfo[[pi]], sucDir, exitStatus,
                                                 timeoutHandler, errorHandler)
                    runningProcInfo[[pi]] <- maybe$procInfo # might have been updated

                    if (maybe$restart)
                    {
                        runningProcs[[pi]] <- do.call(processx::process$new, runningProcInfo[[pi]]$procArgs)
                        finishedRunning <- FALSE
                    }
                }
            }

            if (is.null(runningProcs[[pi]]) || finishedRunning)
            {
                finishedProc <- runningProcs[[pi]]
                finishedProcInfo <- runningProcInfo[[pi]]

                # start next command first, so we can process results while the next is already running
                if (nextCommand <= totCmdCount)
                {
                    if (delayBetweenProc > 0)
                    {
                        diffTime <- curTimeMS() - lastCommandTime
                        if (diffTime < delayBetweenProc)
                            Sys.sleep((delayBetweenProc - diffTime) / 1000)
                    }

                    if (batchSize == 1)
                        ncmd <- 1
                    else
                    {
                        cmdLeft <- totCmdCount - (nextCommand - 1)
                        freeSlots <- sum(sapply(seq_along(runningProcs), function(i) is.null(runningProcs[[i]]) || procFinished(i)))
                        freeSize <- freeSlots * batchSize
                        if (freeSlots > 1 && cmdLeft < freeSize)
                            ncmd <- ceiling(cmdLeft / freeSlots) # divide between free slots
                        else
                            ncmd <- min(batchSize, cmdLeft)
                        # printf("ncmd %d (slot %d, remain: %d, free: %d)\n", ncmd, pi, cmdLeft, freeSlots)
                    }

                    cs <- seq(nextCommand, nextCommand + (ncmd - 1))
                    runningProcInfo[[pi]] <- initCommand(commandQueue[cs], cs, sucDir, printOutput, printError)
                    runningProcs[[pi]] <- do.call(processx::process$new, runningProcInfo[[pi]]$procArgs)

                    # printf("started %d-%d on slot %d\n", nextCommand, runningProcInfo[[pi]]$cmdIndRange[2], pi)
                    lastCommandTime <- curTimeMS()

                    if (!is.null(finishedProc))
                    {
                        # printf("prev time: %s\n", (Sys.time() - finishedProc$get_start_time()) * 1000)
                        finishedCommands <- finishedCommands +
                            (runningProcInfo[[pi]]$cmdIndRange[2]+1) - runningProcInfo[[pi]]$cmdIndRange[1]
                        if (showProgress)
                            setTxtProgressBar(prog, finishedCommands)
                    }

                    nextCommand <- nextCommand + ncmd
                }
                else if (!is.null(runningProcs[[pi]]))
                    runningProcInfo[[pi]]$running <- FALSE

                if (!is.null(finishedProc))
                {
                    inds <- cmdInds[!finishedProcInfo$failed]
                    if (length(inds) > 0)
                        ret[inds] <- lapply(inds, function(ci) finishHandler(cmd = commandQueue[[ci]]))
                }

            }
            else if (!is.null(procTimeout) && runningProcInfo[[pi]]$running)
            {
                # check for timeouts
                kill <- FALSE

                if (length(cmdInds) > 1)
                {
                    # for batch execution: update start time if a new command was started

                    for (i in seq_along(cmdInds))
                    {
                        if (runningProcInfo[[pi]]$failed[i] || runningProcInfo[[pi]]$finished[i])
                            next

                        if (file.exists(file.path(sucDir, cmdInds[i])))
                        {
                            runningProcInfo[[pi]]$finished[i] <- TRUE # now finished
                            runningProcInfo[[pi]]$startTime <- Sys.time()
                        }
                        else if (difftime(Sys.time(), runningProcInfo[[pi]]$startTime, units = "secs")[[1]] > procTimeout)
                            runningProcInfo[[pi]]$timedOut[i] <- kill <- TRUE

                        break
                    }
                }
                else
                    runningProcInfo[[pi]]$timedOut[1] <- kill <-
                        difftime(Sys.time(), runningProcInfo[[pi]]$startTime, units = "secs") > procTimeout

                if (kill)
                {
                    runningProcs[[pi]]$kill()
                    runningProcs[[pi]]$wait()
                }
            }
        }

        if (printOutput || printError || doLog)
        {
            rp <- pruneList(runningProcs)
            pl <- processx::poll(rp, waitTimeout)

            if (FALSE)
            {
            for (pi in seq_along(rp))
            {
                if (doLog) # NOTE: logging currently doesn't work in batch mode
                    cind <- runningProcInfo[[pi]]$cmdIndRange[1]

                if (pl[[pi]][["output"]] == "ready")
                {
                    txt <- rp[[pi]]$read_output()

                    if (printOutput)
                        cat(txt)
                    if (doLog)
                        commandQueue[[cind]]$stdoutLog <- paste0(commandQueue[[cind]]$stdoutLog, txt)

                }
                if (pl[[pi]][["error"]] == "ready")
                {
                    txt <- rp[[pi]]$read_error()
                    if (printError)
                        cat(txt)
                    if (doLog)
                        commandQueue[[cind]]$stderrLog <- paste0(commandQueue[[cind]]$stderrLog, txt)
                }
            }
            }
        }
        else
        {
            # just wait for one of the running processes
            for (pi in seq_along(runningProcs))
            {
                if (!is.null(runningProcInfo[[pi]]) && runningProcInfo[[pi]]$running)
                {
                    runningProcs[[pi]]$wait(waitTimeout)
                    break
                }
            }
        }
    }

    # get rid of potentially large amount of temporary files
    unlink(sucDir, recursive = TRUE)

    if (showProgress)
    {
        setTxtProgressBar(prog, totCmdCount)
        close(prog)
    }

    return(ret)
}
