# Transformation product screening

This chapter describes the various functionality for screening of _transformation products_ (TPs), which are introduced since `patRoon` 2.0. Screening for TPs, i.e. chemicals that are formed from a _parent_ chemical by e.g. chemical or biological processes, has broad applications. For this reason, the TP screening related functionality is designed to be flexible, thus allowing one to use a workflow that is best suited for a particular study.

Regardless, the TP screening workflow in `patRoon` can be roughly summarized as follows:

```{r TPWorkflow,echo=FALSE,out.width="100%"}
plotGV("
digraph Workflow {
  graph [ rankdir = LR ]
  node [ shape = box,
         fixedsize = true,
         width = 2.2,
         height = 1,
         fontsize = 18,
         fillcolor = darkseagreen1,
         style = filled ]

    'Parent screening' -> 'Obtaining TPs' -> 'TP screening' -> 'Linking parent/TPs'
}", height = 90, width = 500)
```

* **Parent screening** During this step a common `patRoon` workflow is used to screen for the parent chemicals of interest. This could be a full non-target analysis with compound annotation or a relative simple suspect or target screening.
* **Obtaining TPs** Data is obtained of potential TPs for the parents of interest. The TPs may originate from a library or predicted _in-silico_. Note that in some workflows this step is omitted (discussed later).
* **TP screening** A suspect screening is performed to find the TPs in the analysis data. 
* **Linking parents and TPs** In the step the parent features are linked with the TP features. Several post-processing functionality exists to improve and prioritize the data.

The next sections will outline more details on these steps are performed and configured. The [last section](#TPsExamples) in this chapter outlines several example workflows.

## Obtaining transformation product data {#genTPs}

UNDONE: cite logic, refs below, adduct description in table

The `generateTPs` function is used to obtain TPs for a particular set of parents. Like other workflow generator functions (`findFeatures`, `generateCompounds`), several algorithms are available that do the actual work.

Algorithm        | Usage                                            | Remarks
---------------- | ------------------------------------------------ | ---------------------------------
[BioTransformer] | `generateTPs(algorithm = "biotransformer", ...)` | Predicts TPs with full structural information
Library          | `generateTPs(algorithm = "library", ...)`        | Obtains transformation products from a library ([PubChem] or custom)
Metabolic logic  | `generateTPs(algorithm = "logic", ...)`          | Uses pre-defined logic to predict TPs based on common elemental differences (e.g. hydroxylation, demethylation)

The `biotransformer` and `library` algorithms provide full structural information of the TPs (e.g. formula, SMILES, predicted Log P). However, these algorithms also depend on the full chemical structure of the parent compound. Hence, these algorithms are typically suitable when parents are known in advance or were found by a suspect screening. On the other hand, metabolic logic only requires the feature mass, and this simplicity allows it to predict TPs for all features. This algorithm is most suitable for full non-target analysis, however, extra care must be taken to rule out false positives.

An overview of common arguments for TP generation is listed below.

Argument                      | Algorithm(s)      | Remarks
----------------------------- | ----------------- | --------------------------------------------------------
`parents`                     | `biotransformer`, `library` | The input parents. See section below.
`fGroups`                     | `logic`           | The input feature groups to calculate TPs for.
`type`                        | `biotransformer`  | The prediction type: `"env"`, `"ecbased"`, `"cyp450"`, `"phaseII"`, `"hgut"`, `"superbio"`, `"allHuman"`. See [BioTransformer] for more details.
`TPLibrary`/`transformations` | `library`/`logic` | [Custom TP library/transformation rules](#TPsCustom).
`adduct`                      | `logic`           | The assumed adduct of the parents (e.g. `"[M+H]+"`). Not needed when adduct annotations are available (or a [sets workflow](#setsWorkflow) is performed).

### Parent input

The input parent structures for the `biotransformer` and `library` algorithms must be one the following:

* A suspect list (follows the same format as [suspect screening](#suspscr))
* A feature groups object with screening results (e.g. obtained with `screenSuspects`, see [suspect screening](#suspscr))
* A `compounds` object obtained with [compound annotation](#compounds)

In the former two cases the parent information is taken from the suspect list or from the hits in a suspect screening worklow, respectively. The last case is more suitable for when the parents are not completely known. In this case, the candidate structures from a [compound annotation](#compounds) are used as input to obtain TPs. Since _all_ the candidates are used, it is highly recommend to filter the object in advance, for instance, with the `topMost` filter. For `library`, the parent input is optional: if no parents are specified then TP data for _all_ parents in the database is used.

For the `logic` algorithm TPs are predicted directly for feature groups. Since this algorithm can only perform very basic validity checks, it is strongly recommended to first prioritize the feature group data.

Some typical examples:

```{r eval=FALSE}
# predict environmental TPs with BioTransformer for all parents in a suspect list
TPsBT <- generateTPs("biotransformer", parents = patRoonData::suspectsPos,
                     type = "env")
# obtain all TPs from the default library
TPsLib <- generateTPs("library")
# get TPs for the parents from a suspect screening
TPsLib <- generateTPs("library", parents = fGroupsScr)
# calculate TPs for all feature groups
TPsLogic <- generateTPs("logic", fGroups, adduct = "[M+H]+")
```

### Processing data

Similar to other workflow data, several generic functions are available to inspect the data:

Generic                            | Classes | Remarks                                                             
-----------------------------------|---------|---------------------------------------------------------------------
`length()`                         | All     | Returns the total number of transformation products
`names()`                          | All     | Returns the names of the parents
`parents()`                        | All     | Returns a table with information about the parents
`products()`                       | All     | Returns a `list` with for each parent a table with TPs
`as.data.table()`, `as.data.frame` | All     | Convert all the object information into a `data.table`/`data.frame`
`"[["` / `"$"` operators           | All     | Extract TP information for a specified parent

Some examples:

```{r include=FALSE,eval=TRUE}
# NOTE: this is always evaluated as it takes very little time...
TPs <- generateTPs("library")
```

```{r TPsProcInsp,eval=TRUE}
# just show a few columns in this example, there are many more!
# note: the double dot syntax (..cols) is necessary since the data is stored as data.tables
cols <- c("name", "formula", "LogP")
parents(TPs)[1:5, ..cols]
TPs[["DEET"]][, ..cols]
TPs[[2]][, ..cols]
as.data.frame(TPs)[1:5, 1:3]
```

In addition, the following generic functions are available to modify or convert the object data:

Generic             | Classes                    | Remarks
------------------- | -------------------------- | --------------------------------------------------------
`"["` operator      | All                        | Subset this object on given parents
`filter`            | `transformationProductsBT` | Filters this object
`convertToSuspects` | All                        | Generates a suspect list of all TPs (and optionally parents) that is suitable for `screenSuspects`
`convertToMFDB`     | `transformationProductsBT`, `transformationProductsLibrary` | Generates a [MetFrag] database for all TPs (and optionally parents)

```{r TPsProcMod,eval=FALSE}
TPs2 <- TPs[1:10] # only keep results for first ten parents

# remove transformation products that have equal formulas as parents (ie isomers)
# may simplify data as these are often difficult to identify
TPsF <- filter(TPs, removeEqualFormulas = TRUE)

# only keep TPs that have a structural similarity to their parent of >= 0.5
TPsF <- filter(TPs, minSimilarity = 0.5)

# do a suspect screening for all TPs and their parents
suspects <- convertToSuspects(TPs, includeParents = TRUE)
fGroupsScr <- screenSuspects(fGroups, suspects, onlyHits = TRUE)

# use the TP data for a specialized MetFrag database
convertToMFDB(TPs, "TP-database.csv", includeParents = FALSE)
compoundsTPs <- generateCompounds(fGroups, mslists, "metfrag", database = "csv",
                                  extraOpts = list(LocalDatabasePath = "TP-database.csv"))
```

The `convertToSuspects` function is always part of a workflow with `biotransformer` or `library` TPs. This is discussed further in the next section. The `convertToMFDB` function is especially handy with `biotransformer` workflows, as it allows generating a compound database for TPs that may not be available in other databases. This is further demonstrated in the [first example](#TPsEx1).

### Custom libraries and transformations {#TPsCustom}

UNDONE: DB refs

By default the `library` and `logic` algorithms use data that is installed with `patRoon` (based on X and Y, respectively). However, it is also possible to use custom data.

To use a custom TP library a simple `data.frame` is needed with the names, SMILES and optionally `log P` values for the parents and TPs. The `log P` values are used for prediction of the retention time direction of a TP compared to its parent, as is discussed further in the next section. The following small library has two TPs for benzotriazole and one for DEET:

```{r TPsCustomDB,eval=TRUE}
myTPLib <- data.frame(parent_name = c("1H-Benzotriazole", "1H-Benzotriazole", "DEET"),
                      parent_SMILES = c("C1=CC2=NNN=C2C=C1", "C1=CC2=NNN=C2C=C1", "CCN(CC)C(=O)C1=CC=CC(=C1)C"),
                      TP_name = c("1-Methylbenzotriazole", "1-Hydroxybenzotriazole", "N-ethyl-m-toluamide"),
                      TP_SMILES = c("CN1C2=CC=CC=C2N=N1", "C1=CC=C2C(=C1)N=NN2O", "CCNC(=O)C1=CC=CC(=C1)C"))
myTPLib
```

To use this library, simply pass it to the `TPLibrary` argument:

```{r eval=FALSE}
TPs <- generateTPs("library", TPLibrary = myTPLib)
```

Similarly, for `logic` a table with custom transformation rules can be specified for TP calculations:

```{r TPCustomLogic,eval=TRUE}
myTrans <- data.frame(transformation = c("hydroxylation", "demethylation"),
                      add = c("O", ""),
                      sub = c("", "CH2"),
                      retDir = c(-1, -1))
myTrans
```

The `add` and `sub` columns are used to denote the elements that are added or subtracted by the reaction. These are used to calculate mass differences between parents and TPs. The `retDir` column is used to indicate the retention time direction of the parent compared to the TP: `-1` (elutes before parent), `1` (elutes after parent) or `0` (similar or unknown). The next section describes how this data can be used to filter TPs. The custom rules can be used by passing them to the `transformations` argument:

```{r eval=FALSE}
TPs <- generateTPs("logic", fGroups, adduct = "[M+H]+", transformations = myTrans)
```

## Linking parent and transformation product features

This section discusses one of the most important steps in a TP screening workflow, which is to link feature groups of parents with those of candidate transformation products. During this step, _components_ are made, where each component consist of one or more feature groups of detected TPs for a particular parent. Note that componentization was [already introduced before](#componentization), but for very different algorithms. However, the data format for TP componentization is highly similar. After componentization, several filters are available to clean and prioritize the data. These can even allow workflows without obtaining potential TPs in advance, which is discussed in the last subsection.

### Componentization

Like [other algorithms]{#components}, the `generateComponents` generic function is used to generate TP components, by setting the `algorithm` parameter to `"TP"`.

The following arguments are of importance:

Argument        | Remarks
--------------- | --------------------------------------------------------------
`fGroups`       | The input feature groups for the _parents_
`fGroupsTPs`    | The input feature groups for the _TPs_
`ignoreParents` | Set to `TRUE` to ignore feature groups in `fGroupsTPs` that also occur in `fGroups`
`TPs`           | The input transformation products, ie as generated by `generateTPs()`
`MSPeakLists`, `formulas`, `compounds` | Annotation objects used for similarity calculatio between the parent and its TPs
`minRTDiff`     | The minimum retention time difference (seconds) of a TP for it to be considered to elute differently than its parent.

#### Feature group input {#TPsFGroups}

The `fGroups`, `fGroupsTPs` and `ignoreParents` arguments are used by the componentization algorithm to identify which feature groups can be considered as parents and which as TPs. Three scenarios are possible:

1. `fGroups=fGroupsTPs` and `ignoreParents=FALSE`: in this case no distinction is made, and all feature groups are considered a parent or TP (default if `fGroupsTPs` is not specified).
2. `fGroups` and `fGroupsTPs` contain different subsets of the _same_ `featureGroups` object and `ignoreParents=FALSE`:  only the feature groups in `fGroups`/`fGroupsTPs` are considered as parents/TPs.
3. As above, but with `ignoreParents=TRUE`: the same distinction is made as above, but any feature groups in `fGroupsTPs` are ignored if also present in `fGroups`.

The first scenario is often used if it is unknown which feature groups may be parents or which are TPs. Furthermore, this scenario may also be used if the dataset is sufficiently simple, for instance, because a suspect screening with the results from `convertToSuspects` (discussed in the previous section) would reliably discriminate between parents and TPs. A workflow with the first scenario is demonstrated in the [second example](#TPsEx2).

In all other cases it is recommended to use either the second or third scenario, since making a prior distinction between parent and TP feature groups greatly simplifies the dataset and reduces false positives. A relative simple example where this can be used is when there are two sample groups: before and after treatment.

```{r eval=FALSE}
componTP <- generateComponents(algorithm = "tp",
                               fGroups = fGroups[, rGroups = "before"],
                               fGroupsTPs = fGroups[, rGroups = "after"])
```

In this example, only those feature groups present in the "before" replicate group are considered as parents, and those in "after" may be considered as a TP. Since it is likely that there will be some overlap in feature groups between both sample groups, the `ignoreParents` flag can be used to not consider any of the overlap for TP assignments:

```{r eval=FALSE}
componTP <- generateComponents(algorithm = "tp",
                               fGroups = fGroups[, rGroups = "before"],
                               fGroupsTPs = fGroups[, rGroups = "after"],
                               ignoreParents = TRUE)
```

More sophisticates ways are of course possible to provide an upfront distinction between parent/TP feature groups. In the [third example](#TPsEx3) a workflow is demonstrated where fold changes are used.

> **NOTE** The feature groups specified for `fGroups`/`fGroupsTPs` _must_ always originate from the same `featureGroups` object.

For the `library` and `biotransformer` algorithms it is mandatory that a suspect screening of parents and TPs is performed prior to componentization. This is necessary for the componentization algorithm to map the feature groups that belong to a particular parent or TP. To do so, the `convertToSuspects` function should be used to prepare the suspect list:

```{r eval=FALSE}
# set includeParents to TRUE since both the parents and TPs are needed
suspects <- convertToSuspects(TPs, includeParents = TRUE)
fGroupsScr <- screenSuspects(fGroups, suspects, onlyHits = TRUE)

# do the componentization
# a similar distinction between fGroups/fGroupsScr as discussed above can of course also be done
componTP <- generateComponents(fGroups = fGroupsScr, ...)
```

Note that in the case a parent suspect is matched to multiple feature groups, a component is made for each match. Similarly, if multiple feature groups match to a TP suspect, all of them will be incorporated in the component.

#### Annotation similarity calculation

UNDONE: link to ms spec sims

If additional annotation data for parents and TPs is given to the componentization algorithm, it will be used to calculate various similarity properties. Often, the chemical structure for a transformation product is similar to that of its parent. Hence, there is a good chance that a parent and its TPs also share similar MS/MS data.

Firstly, if MS peak lists are provided, then the [spectrum similarity] is calculated between each parent and its potential TP candidates. This is performed with all the three different alignment shifts (see the [spectrum similarity section] for more details).

In case `formulas` and/or `compounds` objects are specified, then a parent/TP comparison is made by counting the number of fragments and neutral losses that they share (by using the formula annotations). This property is mainly used for non-target workflows where the identity for a parent and TP is not yet well established. For this reason, fragments and neutral losses reported for _all_ candidates for the parent/TP feature group are considered. Hence, it is highly recommend to pre-treat the annotation objects, for instance, with the `topMost` filter. If both `formulas` and `compounds` are given the results are pooled. Note that each unique fragment/neutral loss is only counted once, thus multiple formula/compound candidates with the same annotations will not skew the results.

### Processing data

The output of TP componentization is an object of the `componentsTPs` class. This _derives_ from the 'regular' `components` class, therefore, all the data processing functionality described [before](#processing) (extraction, subsetting, filtering etc) are also valid for TP components.

Several additional filters are available to prioritize the data:

Filter        | Remarks
------------- | -----------------------------------
`retDirMatch` | If `TRUE` only keep TPs with an expected chromatographic retention direction compared to the parent.
`minSpecSim`, `minSpecPrec`, `minSpecSimBoth` | The minimum spectrum similarity between the parent and TP. Calculated with no, `"precursor"` and `"both"` alignment shifting (see [spectrum similarity]).
`minFragMatches`, `minNLMatches` | Minimum number of formula fragment/neutral loss matches between parent and TP (discussed in previous section).
`formulas`    | A `formulas` object used to further verify candidate TPs that were generated by the `logic` algorithm.

The `retDirMatch` filter compares the expected and observed _retention time direction_ of a TP in order to decide if it should be kept. The direction is a value of either `-1` (TP elutes before parent), `+1` (TP elutes after parent) or `0` (TP elutes very close to the parent or its direction is unknown). The directions are taken from the [generated transformation products](#genTPs). For the `library` and `biotransformer` algorithms the log P values are compared of a TP and its parent. Here, it is assumed that lower log P values result in earlier elution (i.e. typical with reversed phase LC). For the `logic` algorithm the retention time direction is taken from the transformation rules table. Note that specifying a large enough value for the `minRTDiff` argument to `generateComponents` is important to ensure that some tolerance exists while comparing retention time directions of parent and TPs. This filter does nothing if either the observed or expected direction is zero.

When TPs data was generated with the `logic` algorithm it is recommended to use the `formulas` filter. This filter uses formula annotations to verify that (1) a parent feature group contains the elements that are subtracted during the transformation and (2) the TP feature group contains the elements that were added during the transformation. Since the 'right' candidate formula is most likely not yet known, this filter looks at _all_ candidates. Therefore, it is recommended to filter the `formulas` object, for instance, with the `topMost` filter.

### Omitting transformation product input

The `TPs` argument to `generateComponents` can also be omitted. In this case every feature group of `fGroupTPs` is considered to be a potential TP for the potential parents specified for `fGroups`. An advantage is that the screening workflow is not limited to any known TPs or transformations. However, such a workflow has high demands on prioritiation steps before and after the componentization to rule out the many false positives that may occur.

When no transformation data is supplied it is crucial to make [a prior distinction](#TPsFGroups) between parent and TP feature groups. Afterwards, the MS/MS spectral and other annotation similarity filters mentioned in the previous section may be a powerful way to further prioritize data.

The [fourth example](#TPsEx4) demonstrates such a workflow.

## Example workflows {#TPsExamples}

### Screen predicted TPs for targets {#TPsEx1}

```{r eval=FALSE}
# predict TPs for a fixed list of parents
TPs <- generateTPs("biotransformer", parents = patRoonData::suspectsPos)

# screen for the TPs
suspectsTPs <- convertToSuspects(TPs, includeParents = FALSE)
fGroupsTPs <- screenSuspects(fGroups, suspectsTPs, onlyHits = TRUE)

# perform annotation of TPs
mslistsTPs <- generateMSPeakLists(fGroups, "mzr")

# generate MetFrag database
convertToMFDB(TPs, "TP-database.csv", includeParents = FALSE)

# and use it for compound annotation
compoundsTPs <- generateCompounds(fGroupsTPs, mslistsTPs, "metfrag", database = "csv",
                                  extraOpts = list(LocalDatabasePath = "TP-database.csv"))
```

### Screening TPs from a library for suspects {#TPsEx2}

```{r eval=FALSE}
# predict TPs for a fixed list of parents

fGroupsScr <- screenSuspects(fGroups, patRoonData::suspectsPos, onlyHits = TRUE)

TPs <- generateTPs("library", parents = fGroupsScr)

# screen for the TPs
suspects <- convertToSuspects(TPs, includeParents = FALSE)
fGroupsTPs <- screenSuspects(fGroups, suspects, onlyHits = TRUE)

# perform annotation of TPs
mslistsTPs <- generateMSPeakLists(fGroups, "mzr")

# generate MetFrag database
convertToMFDB(TPs, "TP-database.csv", includeParents = FALSE)

# and use it for compound annotation
compoundsTPs <- generateCompounds(fGroupsTPs, mslistsTPs, "metfrag", database = "csv",
                                  extraOpts = list(LocalDatabasePath = "TP-database.csv"))

# filter out candidates without in-silico MS/MS explanations
compoundsTPs <- filter(compoundsTPs, minExplainedPeaks = 1)

# and only keep TPs with high identification levels
fGroupsTPs <- annotateSuspects(fGroupsTPs, MSPeakLists = mslistsTPs, compounds = compoundsTPs)
fGroupsTPs <- filter(fGroupsTPs, maxLevel = 3)

# generate components
componTPs <- generateComponents(fGroupsTPs, "tp", MSPeakLists = mslistsTPs, compunds = compoundsTPs)

reportHTML(fGroupsTPs, MSPeakLists = mslistsTPs, compounds = compoundsTPs, components = componTP)

```

### Non-targeted screening of predicted TPs {#TPsEx3}

### Non-targeted screening of TPs by annotation similarities {#TPsEx4}
