% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R, R/feature_groups.R,
%   R/feature_groups-set.R, R/feature_groups-bruker.R,
%   R/feature_groups-envimass.R, R/feature_groups-kpic2.R,
%   R/feature_groups-openms.R, R/feature_groups-sirius.R,
%   R/feature_groups-xcms.R, R/feature_groups-xcms3.R
\name{feature-grouping}
\alias{feature-grouping}
\alias{groupFeatures,features-method}
\alias{groupFeatures}
\alias{groupFeatures,data.frame-method}
\alias{importFeatureGroups}
\alias{groupFeatures,featuresSet-method}
\alias{makeSet,featureGroups-method}
\alias{makeSet,featureGroupsSet-method}
\alias{importFeatureGroupsBrukerPA}
\alias{importFeatureGroupsEnviMass}
\alias{groupFeaturesKPIC2,features-method}
\alias{groupFeaturesKPIC2,featuresSet-method}
\alias{importFeatureGroupsKPIC2}
\alias{groupFeaturesOpenMS,features-method}
\alias{groupFeaturesSIRIUS}
\alias{groupFeaturesXCMS,features-method}
\alias{groupFeaturesXCMS,featuresSet-method}
\alias{importFeatureGroupsXCMS}
\alias{groupFeaturesXCMS3,features-method}
\alias{groupFeaturesXCMS3,featuresSet-method}
\alias{importFeatureGroupsXCMS3}
\title{Grouping of features}
\usage{
\S4method{groupFeatures}{features}(obj, algorithm, ..., verbose = TRUE)

\S4method{groupFeatures}{data.frame}(obj, algorithm, ..., verbose = TRUE)

importFeatureGroups(path, type, ...)

\S4method{groupFeatures}{featuresSet}(obj, algorithm, ..., verbose = TRUE)

\S4method{makeSet}{featureGroups}(
  obj,
  ...,
  groupAlgo,
  groupArgs = NULL,
  verbose = TRUE,
  adducts = NULL,
  labels = NULL
)

\S4method{makeSet}{featureGroupsSet}(obj, ...)

importFeatureGroupsBrukerPA(
  path,
  feat,
  rtWindow = 12,
  mzWindow = 0.005,
  intWindow = 5,
  warn = TRUE
)

importFeatureGroupsEnviMass(path, feat, positive)

\S4method{groupFeaturesKPIC2}{features}(
  feat,
  rtalign = TRUE,
  loadRawData = TRUE,
  groupArgs = list(tolerance = c(0.005, 12)),
  alignArgs = list(),
  verbose = TRUE
)

\S4method{groupFeaturesKPIC2}{featuresSet}(
  feat,
  groupArgs = list(tolerance = c(0.005, 12)),
  verbose = TRUE
)

importFeatureGroupsKPIC2(picsSetGrouped, analysisInfo)

\S4method{groupFeaturesOpenMS}{features}(
  feat,
  rtalign = TRUE,
  QT = FALSE,
  maxAlignRT = 30,
  maxAlignMZ = 0.005,
  maxGroupRT = 12,
  maxGroupMZ = 0.005,
  extraOptsRT = NULL,
  extraOptsGroup = NULL,
  verbose = TRUE
)

groupFeaturesSIRIUS(analysisInfo, verbose = TRUE)

\S4method{groupFeaturesXCMS}{features}(
  feat,
  rtalign = TRUE,
  loadRawData = TRUE,
  groupArgs = list(mzwid = 0.015),
  retcorArgs = list(method = "obiwarp"),
  verbose = TRUE
)

\S4method{groupFeaturesXCMS}{featuresSet}(feat, groupArgs = list(mzwid = 0.015), verbose = TRUE)

importFeatureGroupsXCMS(xs, analysisInfo)

\S4method{groupFeaturesXCMS3}{features}(
  feat,
  rtalign = TRUE,
  loadRawData = TRUE,
  groupParam = xcms::PeakDensityParam(sampleGroups = analysisInfo(feat)$group),
  retAlignParam = xcms::ObiwarpParam(),
  verbose = TRUE
)

\S4method{groupFeaturesXCMS3}{featuresSet}(
  feat,
  groupParam = xcms::PeakDensityParam(sampleGroups = analysisInfo(feat)$group),
  verbose = TRUE
)

importFeatureGroupsXCMS3(xdata, analysisInfo)
}
\arguments{
\item{obj}{Either a \code{\link{features}} object to be grouped, or a \code{data.frame} with
\link[=analysis-information]{analysis info} to be passed to \code{groupFeaturesSIRIUS} or a \code{featureGroups}
objects passed to \code{makeSet}.}

\item{algorithm}{A \code{character} that specifies the algorithm to be used: either \code{"openms"}, \code{"xcms"},
\code{"xcms3"} or \code{"kpic2"} (\code{features method}), or \code{"sirius"} (\code{data.frame} method).}

\item{\dots}{Any parameters to be passed to the selected grouping/importing algorithm.

  For \code{makeSet}: further \code{\link{featureGroups}} objects that should be used for the
  \link[=sets-workflow]{sets workflow}.}

\item{verbose}{if \code{FALSE} then no text output will be shown.}

\item{path}{The path that should be used for importing. For
\code{importFeatureGroupsBrukerPA} an exported 'bucket table' \file{.txt}
file from Bruker ProfileAnalysis, for \code{importFeatureGroupsBrukerTASQ}
an exported global result table (converted to \file{.csv}) and for
\code{importFeatureGroupsEnviMass} the path of the enviMass project.}

\item{type}{Which file type should be imported or exported: \code{"brukerpa"} (Bruker ProfileAnalysis),
\code{"brukertasq"} (Bruker TASQ), \code{envimass} (\pkg{enviMass}, only import) or \code{"mzmine"} (MZMine, only
export).}

\item{groupAlgo}{groupAlgo The name of the feature grouping algorithm. See the \code{algorithm} argument description.}

\item{groupArgs}{A \code{list} with arguments directly passed to \code{groupFeatures} (can be named). Example:
\code{groupArgs=list(maxAlignMZ=0.002)}.}

\item{adducts}{The adduct assignments to each set. Should either be a \code{list} with \code{\link{adduct}} objects
or a \code{character} vector (\emph{e.g.} \code{"[M+H]+"}). The order should follow that of the objects given to
the \code{obj} and \code{\dots} arguments.}

\item{labels}{The labels, or \emph{set names}, for each set to be created. The order should follow that of the
objects given to the \code{obj} and \code{\dots} arguments. If \code{NULL}, then labels are automatically generated
from the polarity of the specified \code{adducts} argument (\emph{e.g.} \code{"positive"}, \code{"negative"}).}

\item{feat}{The \code{\link{features}} to be grouped. \code{importFeatureGroupsBrukerPA} and
\code{importFeatureGroupsEnviMass} only support features generated by \code{\link{findFeaturesBruker}} and
\code{\link{importFeaturesEnviMass}}, respectively.}

\item{rtWindow, mzWindow, intWindow}{Search window values for retention time
(seconds), \emph{m/z} (Da) and intensity used to find back features within
feature groups from PA (+/- the retention/mass/intensity value of a
feature).}

\item{warn}{Warn about missing or duplicate features when relating them back
from grouped features.}

\item{positive}{Whether data from positive (\code{TRUE}) or negative
(\code{FALSE}) should be loaded.}

\item{rtalign}{Enable retention time alignment.}

\item{loadRawData}{Set to \code{TRUE} if analyses are available as \code{mzXML} or \code{mzML} files. Otherwise MS
data is not loaded, and some dummy data (\emph{e.g.} file paths) is used in the returned object.}

\item{alignArgs}{named \code{character vector} that may contain extra parameters to be used by
\code{\link[KPIC:PICset.align]{KPIC::PICset.align}}.}

\item{picsSetGrouped}{A grouped \code{PIC set} object (\emph{e.g.} as returned by
\code{\link[KPIC:PICset.group]{KPIC::PICset.group}}).}

\item{analysisInfo}{A \code{data.frame} with \link[=analysis-information]{analysis info}.}

\item{QT}{If enabled, use \command{FeatureLinkerUnlabeledQT} instead of
\command{FeatureLinkerUnlabeled} for feature grouping.}

\item{maxAlignRT, maxAlignMZ}{Used for retention alignment. Maximum retention
time or m/z difference (seconds/Dalton) for feature pairing. Sets
\code{-algorithm:pairfinder:distance_RT:max_difference} and
\code{-algorithm:pairfinder:distance_MZ:max_difference} otpions,
respectively.}

\item{maxGroupRT, maxGroupMZ}{as \code{maxAlignRT} and \code{maxAlignMZ}, but
for grouping of features. Sets \code{-algorithm:distance_RT:max_difference}
and \code{-algorithm:distance_MZ:max_difference} options, respectively.}

\item{extraOptsRT, extraOptsGroup}{Named \code{list} containing extra options
that will be passed to \command{MapAlignerPoseClustering} or
\command{FeatureLinkerUnlabeledQT/FeatureLinkerUnlabeled}, respectively.
Any options specified here will override any of the above. Example:
\code{extraOptsGroup=list("-algorithm:distance_RT:max_difference"=12)}
(corresponds to setting \code{maxGroupRT=12}). Set to \code{NULL} to
ignore.}

\item{retcorArgs}{named \code{character vector} that may contain extra parameters to be used by
\code{\link[xcms:retcor-methods]{xcms::retcor}}.}

\item{xs}{An \code{\link{xcmsSet}} object.}

\item{groupParam, retAlignParam}{parameter object that is directly passed to
\code{\link[xcms:groupChromPeaks]{xcms::groupChromPeaks}} and
\code{\link[xcms:adjustRtime]{xcms::adjustRtime}}, respectively.}

\item{xdata}{An \code{\link{XCMSnExp}} object.}
}
\value{
An object of a class which is derived from \code{\link{featureGroups}}.

\code{makeSet} and the \code{\link{featuresSet}} method of \code{groupFeatures} return a
  \code{\link{featuresGroupsSet}} object.
}
\description{
Functions and classes for grouping of features across analyses.
}
\details{
After \link[=feature-finding]{features have been found} the logical next step is to align and group them across
analyses. This process is necessary to allow comparison of features between multiple analyses, which otherwise would
be difficult due to small deviations in retention and mass data. Thus, algorithms of 'feature groupers' are used to
collect features with similar retention and mass data. In addition, advanced retention time alignment algorithms
exist to enhance grouping of features even with relative large retention time deviations (\emph{e.g.} possibly
observed from analyses collected over a long period). Like \link[=feature-finding]{finding of features}, various
algorithms are supported which may have many parameters that can be fine-tuned. This fine-tuning is likely to be
necessary, since optimal settings often depend on applied methodology and instrumentation.

\code{groupFeatures} is a generic function that will group features using one of the supported algorithms. The actual
  functionality is provided by algorithm specific functions such as \code{groupFeaturesOpenMS} and \code{groupFeaturesXCMS3}. While these
  functions may be called directly, \code{groupFeatures} provides a generic interface and is therefore usually preferred.

The \code{data.frame} method for \code{groupFeatures} is a special case that currently only supports the
  \code{"sirius"} algorithm.

\code{importFeatureGroups} is a generic function to import feature
  groups produced by other software. The actual functionality is provided by
  specific functions such as \code{importFeatureGroupsBrukerPA} and
  \code{importFeatureGroupsEnviMass}.

\code{makeSet} is used to initiate a \link[=sets-workflow]{sets workflow}. See the \verb{Sets workflows}
  section for more details.

\code{importFeatureGroupsBrukerPA} imports grouped features
  generated with Bruker ProfileAnalysis (PA). To do so, a 'bucket table'
  should be generated using PA and exported as \file{.txt} file. Please note
  that this function only supports features generated by
  \code{\link{findFeaturesBruker}} and it is \strong{crucial} that
  DataAnalysis files remain unchanged when features are collected and the
  bucket table is generated. Furthermore, please note that PA does not retain
  information about originating features for generated buckets. For this
  reason, this function tries to find back the original features and care
  must be taken to correctly specify search parameters (\code{rtWindow},
  \code{mzWindow}, \code{intWindow}).

\code{importFeatureGroupsEnviMass} imports grouped features
  ('profiles') generated with \pkg{enviMass}. Note that this function
  \emph{only} imports 'raw' profiles, \emph{not} any results from further
  componentization steps performed in \pkg{enviMass}. Furthermore, this
  functionality has only been tested with older versions of \pkg{enviMass}.
  Finally, please note that this function only supports features imported by
  \code{\link{importFeaturesEnviMass}} (obviously, the same project should be
  used for both importing functions).

\code{groupFeaturesKPIC2} uses the the
  \href{https://github.com/hcji/KPIC2}{KPIC2} \R package for grouping of features. Grouping of features and alignment of
  their retention times are performed with the
  \code{\link[KPIC:PICset.group]{KPIC::PICset.group}} and
  \code{\link[KPIC:PICset.align]{KPIC::PICset.align}} functions, respectively.

\code{importFeatureGroupsKPIC2} imports grouped features from an \pkg{KPIC} object.

\code{groupFeaturesOpenMS} uses the OpenMS tools for grouping of
  features (see \url{http://www.openms.de}). Retention times may be aligned
  by the
  \href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/TOPP_MapAlignerPoseClustering.html}{MapAlignerPoseClustering}
   TOPP tool. Grouping is achieved by either the
  \href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/TOPP_FeatureLinkerUnlabeled.html}{FeatureLinkerUnlabeled}
   or
  \href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/TOPP_FeatureLinkerUnlabeledQT.html}{FeatureLinkerUnlabeledQT}
   TOPP tools.

\code{groupFeaturesSIRIUS} uses \href{https://bio.informatik.uni-jena.de/software/sirius/}{SIRIUS} to find
  \emph{and} group features. This is done by running the \command{lcms-align} command on every analyses at once. Note
  that grouping feature data from other algorithms than \command{SIRIUS} are therefore not supported.

\code{groupFeaturesXCMS} uses the \pkg{xcms} package for grouping of features. Grouping of features and
  alignment of their retention times are performed with the \code{\link[xcms:group-methods]{xcms::group}} and
  \code{\link[xcms:retcor-methods]{xcms::retcor}} functions, respectively. Both functions have an extensive list of
  parameters to modify their behaviour and may therefore be used to potentially optimize results.

\code{importFeatureGroupsXCMS} converts grouped features from an
  \code{\link{xcmsSet}} object (from the \pkg{xcms} package).

\code{groupFeaturesXCMS3} uses the new interface from the \pkg{xcms}
  package for grouping of features. Grouping of features and alignment of
  their retention times are performed with the
  \code{\link[xcms:groupChromPeaks]{xcms::groupChromPeaks}} and
  \code{\link[xcms:adjustRtime]{xcms::adjustRtime}} functions, respectively.
  Both of these functions support an extensive amount of parameters that
  modify their behaviour and may therefore require optimization.

\code{importFeatureGroupsXCMS3} converts grouped features from an
  \code{\link{XCMSnExp}} object (from the \pkg{xcms} package).
}
\note{
\code{makeSet} Currently does not support making sets from \code{\link{featureGroupsSet}} objects.
}
\section{Sets workflows}{
 With a \link[=sets-workflow]{sets workflow} the features are first neutralized, \emph{i.e.}
  their \emph{m/z} values is replaced by their neutral monoisotopic mass. The latter is calculated from adduct
  annotations, specified either directly, or already present in the input objects. The features are then grouped by
  any of the \code{groupFeatures} algorithms. The neutralization step ensures that features measured with \emph{e.g.}
  different ionization polarities can be grouped since their neutral mass will be the same. The sets workflow is
  initiated in either of the following two ways: \enumerate{

  \item The \code{groupFeatures} method can be called with a \code{\link{featuresSet}} object (generated with the
  \link[=makeSet,features-method]{features method} of \code{makeSet}).

  \item By using the \code{makeSet} method for \code{featureGroups}. This uses the
  \link[=makeSet,features-method]{features method} internally to first create a \code{\link{featuresSet}} object from
  all the feature data inside the input \code{featureGroups} objects. The (neutralized) features are then
  (re-)grouped with \code{groupFeatures}.

  }

  The advantage of the second method is that it preserves adduct annotations present in the input
  \code{featureGroups} objects (\emph{e.g.} as set by \code{selectIons} or \code{adducts<-}). Furthermore, the second
  approach allows more advanced workflows where the input \code{featureGroups} are first pre-treated with \emph{e.g.}
  filter before the sets object is made. On the other hand, the first approach is easier as it doesn't require
  intermediate feature grouping steps, and is often sufficient as adduct annotations can be made afterwards with
  \code{selectIons}/\code{adducts<-}, and most \code{filter} operations do not need to be done per individual set.

  With both approaches the resulting \code{\link{featureGroupsSet}} object will contain adduct annotations, either
  based on those already present from input \code{featureGroups} objects or as specified by the \code{adducts}
  argument to \code{makeSets}.

  \strong{NOTE} the \code{loadRawData} and arguments related to retention time alignment (\emph{e.g.} \code{rtalign},
  \code{retcorArgs}) are currently not supported for sets workflows when using algorithms from \pkg{KPIC2} or
  \pkg{XCMS}.
}

\references{
\insertRef{Ji2017}{patRoon}

\insertRef{Rst2016}{patRoon} \cr\cr
  \href{https://pugixml.org/}{pugixml} (via \href{http://www.rcpp.org/}{Rcpp}) is used to process OpenMS XML output. \cr\cr
  \addCitations{Rcpp}{1} \cr\cr
  \addCitations{Rcpp}{2} \cr\cr
  \addCitations{Rcpp}{3}

\insertRef{Dhrkop2019}{patRoon}

\addCitations{xcms}{1} \cr\cr \addCitations{xcms}{2} \cr\cr \addCitations{xcms}{3}

\addCitations{xcms}{1} \cr\cr \addCitations{xcms}{2} \cr\cr
  \addCitations{xcms}{3}
}
\seealso{
\code{\link{featureGroups-class}}
}
