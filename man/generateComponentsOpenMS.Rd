% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/components-openms.R
\name{generateComponentsOpenMS}
\alias{generateComponentsOpenMS}
\alias{generateComponentsOpenMS,featureGroups-method}
\alias{generateComponentsOpenMS,featureGroupsSet-method}
\title{Componentization of adducts, isotopes etc. with OpenMS}
\usage{
generateComponentsOpenMS(fGroups, ...)

\S4method{generateComponentsOpenMS}{featureGroups}(
  fGroups,
  ionization = NULL,
  chargeMin = 1,
  chargeMax = 1,
  chargeSpan = 3,
  qTry = "heuristic",
  potentialAdducts = NULL,
  minRTOverlap = 0.66,
  retWindow = 1,
  absMzDev = 0.005,
  minSize = 2,
  relMinAdductAbundance = 0.75,
  adductConflictsUsePref = TRUE,
  NMConflicts = c("preferential", "mostAbundant", "mostIntense"),
  prefAdducts = c("[M+H]+", "[M-H]-"),
  extraOpts = NULL
)

\S4method{generateComponentsOpenMS}{featureGroupsSet}(
  fGroups,
  ionization = NULL,
  chargeMin = 1,
  chargeMax = 1,
  chargeSpan = 3,
  qTry = "heuristic",
  potentialAdducts = NULL,
  ...
)
}
\arguments{
\item{fGroups}{\code{\link{featureGroups}} object for which components should be generated.}

\item{\dots}{\setsWF Further arguments passed to the non-sets workflow method.}

\item{ionization}{Which ionization polarity was used to generate the data: should be \code{"positive"}
  or \code{"negative"}. If the \code{featureGroups} object has adduct annotations, and \code{ionization=NULL}, the
  ionization will be detected automatically.

  \setsWF This parameter is not supported for sets workflows, as the ionization will always be detected
  automatically.}

\item{chargeMin, chargeMax}{The minimum/maximum charge to consider. Corresponds to the
\command{algorithm:MetaboliteFeatureDeconvolution:charge_min}/\command{algorithm:MetaboliteFeatureDeconvolution:charge_min}
 options.}

\item{chargeSpan}{The maximum charge span for a single analyte. Corresponds to
\command{algorithm:MetaboliteFeatureDeconvolution:charge_span_max}.}

\item{qTry}{Sets how charges are determined. Corresponds to \command{algorithm:MetaboliteFeatureDeconvolution:q_try}.
Valid options are \code{"heuristic"} and \code{"all"} (the \code{"feature"} option from \command{OpenMS} is
currently not supported).}

\item{potentialAdducts}{The adducts to consider. Should be a \code{numeric} vector with probabilities for each
  adduct, \emph{e.g.} \code{potentialAdducts=c("[M+H]+" = 0.8, "[M+Na]+" = 0.2)}. Note that the sum of probabilities
  should always be \samp{1}. Furthermore, note that additions of multiple adducts should be controlled by the
  \code{chargeMin}/\code{chargeMax} arguments (and \emph{not} with \code{potentialAdducts}), \emph{e.g.} if
  \code{chargeMax=2} then both \code{[M+H]+} and \code{[2M+H]2+} may be considered. Please see the
  \command{algorithm:MetaboliteFeatureDeconvolution:potential_adducts} option of
  \href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/UTILS_MetaboliteAdductDecharger.html}{MetaboliteAdductDecharger}
   for more details. If \code{NULL} then the a default is chosen with \code{\link{defaultOpenMSAdducts}} (which is
  \emph{not} the same as \command{OpenMS}).

  \setsWF Should be a \code{list} where each entry specifies the potential adducts for a set. Should either be named
  with the sets names or follow the same order as \code{sets(fGroups)}. Example:
  \code{potentialAdducts=list(positive=c("[M+H]+" = 0.8, "[M+Na]+" = 0.2), negative=c("[M-H]-" = 0.8, "[M-H2O-H]-" =
  0.2))}}

\item{minRTOverlap, retWindow}{Sets feature retention tolerances when grouping features. Sets the
\command{"algorithm:MetaboliteFeatureDeconvolution:retention_max_diff"} and
\command{algorithm:MetaboliteFeatureDeconvolution:min_rt_overlap} options.}

\item{absMzDev}{Maximum absolute \emph{m/z} deviation. Sets the \command{algorithm:MetaboliteFeatureDeconvolution:mass_max_diff} option}

\item{minSize}{The minimum size of a component. Smaller components than this size will be removed. See note below.}

\item{relMinAdductAbundance}{The minimum relative abundance (\samp{0-1}) that an adduct should be assigned to
features within the same feature group. See the \verb{Feature components} section for more details.}

\item{adductConflictsUsePref}{If set to \code{TRUE}, and not all adduct assigments to the features within a feature
group are equal and at least one of those adducts is a preferential adduct (\code{prefAdducts} argument), then only
the features with (the lowest ranked) preferential adduct are considered. In all other cases or when
\code{adductConflictsUsePref=FALSE} only features with the most frequently assigned adduct is considered. See the
\verb{Feature components} section for more details.}

\item{NMConflicts}{The strategies to employ when not all neutral masses within a component are equal. Valid options
are: \code{"preferential"}, \code{"mostAbundant"} and \code{"mostIntense"}. Multiple strategies are possible, and
will be executed in the given order until one succeeds. See the \verb{Feature components} section for more details.}

\item{prefAdducts}{A \code{character} vector with one or more \emph{preferential adducts}. See the \verb{Feature
components} section for more details.}

\item{extraOpts}{Named character vector with extra command line parameters directly passed to
\command{MetaboliteAdductDecharger}. Set to \code{NULL} to ignore.}
}
\value{
A \code{\link{componentsFeatures}} derived object.
}
\description{
Uses the
\href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/UTILS_MetaboliteAdductDecharger.html}{MetaboliteAdductDecharger}
utility (see \url{http://www.openms.de}) to generate components.
}
\details{
This function uses OpenMS to generate components. This function is called when calling \code{generateComponents} with
  \code{algorithm="openms"}.

Features that show highly similar chromatographic elution profiles are grouped, and subsequently annotated
  with their adducts.
}
\section{Feature components}{
 The returned components are based on so called \emph{feature components}. Unlike other
  algorithms, components are first made on a feature level (per analysis), instead of for complete feature groups. In
  the final step the feature components are converted to 'regular' components by employing a consensus approach with
  the following steps:

  \enumerate{

  \item If an adduct assigned to a feature only occurs as a minority compared to other adduct assigments within the
  same feature group, it is considered as an outlier and removed accordingly (controlled by the
  \code{relMinAdductAbundance} argument).

  \item For features within a feature group, only keep their adduct assignment if it occurs as the most frequent or
  is preferential (controlled by \code{adductConflictsUsePref} and \code{prefAdducts} arguments).

  \item Components are made by combining the feature groups for which at least one of their features are jointly
  present in the same feature component.

  \item Conflicts of neutral mass assignments within a component (\emph{i.e.} not all are the same) are dealt with.
  Firstly, all feature groups with an unknown neutral mass are split in another component. Then, if conflicts still
  occur, the feature groups with similar neutral mass (determined by \code{absMzDev} argument) are grouped. Depending
  on the \code{NMConflicts} argument, the group with one or more preferential adduct(s) or that is the largest or
  most intense is selected, whereas others are removed from the component. In case multiple groups contain
  preferential adducts, and \samp{>1} preferential adducts are available, the group with the adduct that matches
  first in \code{prefAdducts} 'wins'. In case of ties, one of the next strategies in \code{NMConflicts} is tried.

  \item If a feature group occurs in multiple components it will be removed completely.

  \item the \code{minSize} filter is applied.

  }
}

\section{Sets workflows}{
 In a \link[=sets-workflow]{sets workflow} the componentization is first performed for each
  set independently. The resulting components are then all combined in a \code{\link{componentsSet}} object. Note that
  the components themselves are never merged. The components are renamed to include the set name from which they were
  generated (\emph{e.g.} \code{"CMP1"} becomes \code{"CMP1-positive"}).
}

\section{Parallelization}{
 generateComponentsOpenMS uses multiprocessing to parallelize
  computations. Please see the parallelization section in the handbook for
  more details and \link[=patRoon-package]{patRoon options} for configuration
  options.
}

\references{
\insertRef{Bielow2010}{patRoon}
}
\seealso{
\code{\link{generateComponents}} for more details and other algorithms.
}
