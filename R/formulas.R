#' @include main.R
#' @include feature_annotations.R
NULL

#' Formula lists class
#'
#' Contains data of generated chemical formulae for given feature groups.
#'
#' \code{formulas} objects are obtained from \link[=formula-generation]{formula
#' generators}.
#'
#' @slot formulas,featureFormulas Lists of all generated formulae. Use the
#'   \code{annotations} method for access.
#' @slot scoreRanges The original min/max values of all scorings when candidate
#'   results were generated. This is used for normalization.
#'
#' @param obj,x,object,formulas The \code{formulas} object.
#' @param \dots For \code{plotSpectrum}: Further arguments passed to
#'   \code{\link[graphics]{plot}}.
#'
#'   Others: Any further (and unique) \code{formulas} objects.
#' @param OM For \code{as.data.table}: if set to \code{TRUE} several columns
#'   with information relevant for organic matter (OM) characterization will be
#'   added (e.g. elemental ratios, classification). This will also make sure
#'   that \code{countElements} contains at least C, H, N, O, P and S.
#'
#'   For \code{filter}: If \code{TRUE} then several filters are applied to
#'   exclude unlikely formula candidates present in organic matter (OM). See
#'   Source section for details.
#' @param labels A \code{character} with names to use for labelling. If
#'   \code{NULL} labels are automatically generated.
#'
#' @templateVar seli analyses
#' @templateVar selOrderi analyses()
#' @templateVar selj feature groups
#' @templateVar selOrderj groupNames()
#' @templateVar optionalji TRUE
#' @templateVar dollarOpName feature group
#' @template sub_op-args
#'
#' @templateVar normParam normalizeScores
#' @templateVar excludeParam excludeNormScores
#' @template norm-args
#'
#' @section Source: Calculation of the aromaticity index (AI) and related double
#'   bond equivalents (DBE_AI) is performed as described in Koch 2015. Formula
#'   classification is performed by the rules described in Abdulla 2013.
#'   Filtering of OM related molecules is performed as described in Koch 2006
#'   and Kujawinski 2006. (see references).
#'
#' @references \insertRef{Koch2015}{patRoon} \cr\cr
#'   \insertRef{Abdulla2013}{patRoon} \cr\cr
#'   \insertRef{Koch2006}{patRoon} \cr\cr
#'   \insertRef{Kujawinski2006}{patRoon}
#'
#' @templateVar class formulas
#' @template class-hierarchy
#'
#' @export
formulas <- setClass("formulas", slots = c(featureFormulas = "list"),
                     contains = "featureAnnotations")

setMethod("initialize", "formulas", function(.Object, ...)
{
    .Object <- callNextMethod(.Object, ...)

    # NOTE/UNDONE: change this whenever we want formula scoring normalization
    # based on _all_ results generated by the algorithm (ie like compounds)
    if (length(.Object@groupAnnotations) > 0)
    {
        .Object@scoreRanges <- sapply(.Object@groupAnnotations, calculateFormScoreRanges, mergedConsensusNames(.Object),
                                      simplify = FALSE)
        .Object@scoreTypes <- unique(unlist(lapply(.Object@scoreRanges, names)))
    }
    
    .Object@scoreRanges <- makeEmptyListNamed(.Object@scoreRanges)
    .Object@scoreTypes <- makeEmptyListNamed(.Object@scoreTypes)
    
    .Object@featureFormulas <- makeEmptyListNamed(.Object@featureFormulas)
    
    .Object@groupAnnotations <- lapply(.Object@groupAnnotations, function(ann) ann[, UID := neutral_formula])
    
    return(.Object)
})

#' @rdname formulas-class
formulasConsensus <- setClass("formulasConsensus",
                              slots = c(mergedConsensusNames = "character"),
                              contains = "formulas")
setMethod("mergedConsensusNames", "formulasConsensus", function(obj) obj@mergedConsensusNames)


#' @describeIn formulas Accessor method to obtain generated formulae.
#'
#' @param features If \code{TRUE} returns formula data for features, otherwise
#'   for feature groups.
#'
#' @return \code{annotations} returns a \code{list} containing for each feature
#'   group (or feature if \code{features=TRUE}) a \code{\link{data.table}}
#'   with an overview of all generated formulae and other data such as candidate
#'   scoring and MS/MS fragments.
#'
#' @export
setMethod("annotations", "formulas", function(obj, features = FALSE) if (features) obj@featureFormulas else callNextMethod())

#' @templateVar class formulas
#' @templateVar what analyses
#' @template strmethod
#' @export
setMethod("analyses", "formulas", function(obj) names(obj@featureFormulas))

#' @export
setMethod("defaultExclNormScores", "formulas", function(obj) character())

setMethod("annScoreNames", "formulas", function(obj, onlyNums) formulaScorings()$name)

#' @describeIn formulas Show summary information for this object.
#' @export
setMethod("show", "formulas", function(object)
{
    callNextMethod()
    
    ft <- annotations(object, TRUE)
    hasFeatForms <- length(ft) > 0
    ftcounts <- if (hasFeatForms) recursiveApplyDT(ft, function(x) length(unique(x$neutral_formula)), sapply) else 0
    ma <- mean(sapply(ftcounts, sum))
    mft <- mean(sapply(ftcounts, mean))
    printf("Formulas assigned to features:\n")
    printf("  - Total formula count: %d\n", sum(unlist(ftcounts)))
    printf("  - Average formulas per analysis: %.1f\n", ma)
    printf("  - Average formulas per feature: %.1f\n", mft)
    
    gft <- annotations(object)
    mfg <- if (length(gft) > 0) sapply(gft, function(ft) length(unique(ft$neutral_formula))) else 0
    printf("Formulas assigned to feature groups:\n")
    printf("  - Total formula count: %d\n", sum(mfg))
    printf("  - Average formulas per feature group: %.1f\n", mean(mfg))
})

#' @describeIn formulas Extract a formula table. If both arguments (\code{i} and
#'   \code{j}) are specified, the feature specific formula table belonging to
#'   the analysis (\code{i})/feature group (\code{j}) is returned. Otherwise the
#'   formula table for the feature group specified by \code{j} is returned.
#' @export
setMethod("[[", c("formulas", "ANY", "ANY"), function(x, i, j)
{
    assertExtractArg(i)
    if (!missing(j))
        assertExtractArg(j)
    
    if (!missing(j))
    {
        # both arguments specified, return feature formula table
        
        if (length(x@featureFormulas) == 0)
            stop("This object does not contain formulas for features.")
        
        if (!is.character(i))
            i <- analyses(x)[i]
        
        if (!is.character(j))
            j <- groupNames(x)[j]
        
        return(x@featureFormulas[[c(i, j)]])
    }
    
    return(callNextMethod())
})

#' @export
setMethod("delete", "formulas", function(obj, i = NULL, j = NULL, ...)
{
    obj <- callNextMethod()
    
    obj@featureFormulas <- lapply(obj@featureFormulas, function(a) pruneList(a[groupNames(obj)]))
    obj@featureFormulas <- pruneList(obj@featureFormulas, TRUE)
    
    return(obj)
})

#' @describeIn formulas Generates a table with all candidate formulae for each
#'   feature group and other information such as element counts.
#'
#' @param average If set to \code{TRUE} an 'average formula' is generated for
#'   each feature group by combining all elements from all candidates and
#'   averaging their amounts. This obviously leads to non-existing formulae,
#'   however, this data may be useful to deal with multiple candidate formulae
#'   per feature group when performing elemental characterization.
#' @param countElements,countFragElements A \code{character} vector with
#'   elements that should be counted for each MS(/MS) formula candidate. For
#'   instance, \code{c("C", "H")} adds columns for both carbon and hydrogen
#'   amounts of each formula. Note that the neutral formula
#'   (\code{neutral_formula} column) is used to count elements of non-fragmented
#'   formulae, whereas the charged formula of fragments (\code{ion_formula}
#'   column in \code{fragInfo} data) is used for fragments. Set to \code{NULL} to not count any
#'   elements.
#'
#' @template as_data_table-args
#'
#' @return \code{as.data.table} returns a \code{\link{data.table}}.
#'
#' @export
setMethod("as.data.table", "formulas", function(x, fGroups = NULL, fragments = FALSE, countElements = NULL,
                                                countFragElements = NULL, OM = FALSE, normalizeScores = "none",
                                                excludeNormScores = defaultExclNormScores(x), average = FALSE)
{
    checkmate::assertFlag(average)
    
    ret <- callNextMethod(x, fGroups = fGroups, fragments = fragments, countElements = countElements,
                          countFragElements = countFragElements, OM = OM, normalizeScores = normalizeScores,
                          excludeNormScores = excludeNormScores)
    
    if (average)
    {
        ret[, formula_avg_count := .N, by = "group"]
        
        avgCols <- getAllMergedConsCols(c("ion_formula", "neutral_formula"), names(ret), mergedConsensusNames(x))
        ret[, (avgCols) := lapply(.SD, function(f)
        {
            f <- f[!is.na(f)]
            if (length(f) == 0)
                return(NA_character_)
            return(averageFormulas(unique(f)))
        }), .SDcols = avgCols, by = "group"]
        
        # just keep the essential columns as the rest doesn't make too much sense anymore
        keepCols <- c("group", avgCols)
        ret <- ret[, keepCols, with = FALSE]
        ret <- unique(ret, by = c("group", "neutral_formula"))
        
        # update if needed
        ret <- addElementInfoToAnnTable(ret, countElements, countFragElements, OM, TRUE)
    }
    
    return(ret[])
})

#' @describeIn formulas Returns an MS/MS peak list annotated with data from a
#'   given candidate formula.
#'
#' @param onlyAnnotated Set to \code{TRUE} to filter out any peaks that could
#'   not be annotated.
#'
#' @export
setMethod("annotatedPeakList", "formulas", function(obj, index, groupName, analysis = NULL, MSPeakLists,
                                                    onlyAnnotated = FALSE)
{
    # NOTE: keep args in sync with sets method
    
    ac <- checkmate::makeAssertCollection()
    checkmate::assertCount(index, positive = TRUE, add = ac)
    assertChoiceSilent(groupName, groupNames(obj), add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertFlag(onlyAnnotated, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(analysis))
        return(doAnnotatePeakList(MSPeakLists[[analysis, groupName]][["MSMS"]],
                                  annotations(obj, TRUE)[[analysis, groupName]], index, onlyAnnotated))
    
    return(doAnnotatePeakList(MSPeakLists[[groupName]][["MSMS"]], annotations(obj)[[groupName]], index,
                              onlyAnnotated))
})

#' @describeIn formulas Plots an annotated spectrum for a given candidate
#'   formula of a feature or feature group.
#'
#' @param precursor The formula of the precursor (in neutral form).
#' @param analysis A \code{character} specifying the analysis for which the
#'   annotated spectrum should be plotted. If \code{NULL} then annotation
#'   results for the complete feature group will be plotted.
#' @param title The title of the plot. Set to \code{NULL} for an automatically
#'   generated title.
#'
#' @template plotSpec-args
#'
#' @template useGGplot2
#'
#' @template plot-lim
#'
#' @template fsubscript_source
#'
#' @return \code{plotSpectrum} will return a \code{\link[=ggplot2]{ggplot
#'   object}} if \code{useGGPlot2} is \code{TRUE}.
#'
#' @export
setMethod("plotSpectrum", "formulas", function(obj, index, groupName, analysis = NULL, MSPeakLists,
                                               title = NULL, specSimParams = getDefSpecSimParams(),
                                               useGGPlot2 = FALSE, mincex = 0.9, xlim = NULL, ylim = NULL, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertIntegerish(index, lower = 1, min.len = 1, max.len = 2, any.missing = FALSE, add = ac)
    checkmate::assertCharacter(groupName, min.len = 1, max.len = 2, min.chars = 1, add = ac)
    checkmate::assertCharacter(analysis, min.len = 1, max.len = 2, min.chars = 1, null.ok = TRUE, add = ac)
    if (length(index) != length(groupName))
        stop("Lengths of index and groupName should be equal.")
    if (!is.null(analysis) && length(analysis) != length(groupName))
        stop("Lengths of analysis and groupName should be equal.")
    assertSpecSimParams(specSimParams, add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertString(title, null.ok = TRUE, add = ac)
    checkmate::assertFlag(useGGPlot2, add = ac)
    checkmate::assertNumber(mincex, lower = 0, finite = TRUE, add = ac)
    assertXYLim(xlim, ylim, add = ac)
    checkmate::reportAssertions(ac)
    
    if (length(groupName) == 1)
    {
        spec <- annotatedPeakList(obj, index, groupName, analysis, MSPeakLists)
        if (is.null(spec))
            return(NULL)
        
        if (index > nrow(obj[[groupName]]))
            stop(sprintf("Specified candidate index out of range %d/%d", index, nrow(obj[[groupName]])), call. = FALSE)

        if (is.null(title))
            title <- subscriptFormula(obj[[groupName]]$neutral_formula[index])
        
        if (useGGPlot2)
            return(makeMSPlotGG(getMSPlotData(spec, 2)) + ggtitle(title))
        
        makeMSPlot(getMSPlotData(spec, 2), mincex, xlim, ylim, ..., main = title)
    }
    else
    {
        for (i in seq_len(2))
        {
            if (index[i] > nrow(obj[[groupName[i]]]))
                stop(sprintf("Specified candidate index out of range %d/%d", index[i], nrow(obj[[groupName[i]]])),
                     call. = FALSE)
        }
        
        if (is.null(title))
            title <- subscriptFormula(obj[[groupName[1]]]$neutral_formula[index[1]],
                                      formulas2 = obj[[groupName[2]]]$neutral_formula[index])
        
        binnedPLs <- getBinnedPLPair(MSPeakLists, groupName, analysis, 2, specSimParams, "unique", mustExist = TRUE)
        
        topSpec <- mergeBinnedAndAnnPL(binnedPLs[[1]], annotatedPeakList(obj, index[1], groupName[1], analysis[1],
                                                                         MSPeakLists), 1)
        
        bottomSpec <- mergeBinnedAndAnnPL(binnedPLs[[2]], annotatedPeakList(obj, index[2], groupName[2],
                                                                            analysis[2], MSPeakLists), 2)
        plotData <- getMSPlotDataOverlay(list(topSpec, bottomSpec), TRUE, FALSE, 2, "overlap")
        makeMSPlotOverlay(plotData, title, mincex, xlim, ylim, useGGPlot2, ...)
    }
})

setMethod("plotSpectrumHash", "formulas", function(obj, index, groupName, analysis = NULL, MSPeakLists,
                                                     title = NULL, specSimParams = getDefSpecSimParams(),
                                                     useGGPlot2 = FALSE, mincex = 0.9, xlim = NULL, ylim = NULL, ...)
{
    if (length(groupName) > 1)
    {
        # recursive call for both candidates
        args <- list(obj = obj, MSPeakLists = MSPeakLists, title = title, specSimParams = specSimParams,
                     useGGPlot2 = useGGPlot2, mincex = mincex, xlim = xlim, ylim = ylim, ...)
        return(makeHash(do.call(plotSpectrumHash, c(args, list(index = index[1], groupName = groupName[1],
                                                               analysis = analysis[1]))),
                        do.call(plotSpectrumHash, c(args, list(index = index[2], groupName = groupName[2],
                                                               analysis = analysis[2])))))
    }
    
    return(makeHash(index, annotatedPeakList(obj, index, groupName, analysis, MSPeakLists),
                    title, useGGPlot2, mincex, xlim, ylim, ...))
})

#' @describeIn formulas Plots a barplot with scoring of a candidate formula.
#'
#' @export
setMethod("plotScores", "formulas", function(obj, index, groupName, analysis = NULL, normalizeScores = "max",
                                             excludeNormScores = defaultExclNormScores(obj), useGGPlot2 = FALSE)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertCount(index, positive = TRUE, add = ac)
    checkmate::assertString(groupName, min.chars = 1, add = ac)
    checkmate::assertString(analysis, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertChoice(normalizeScores, c("none", "max", "minmax"))
    checkmate::assertCharacter(excludeNormScores, min.chars = 1, null.ok = TRUE, add = ac)
    checkmate::assertFlag(useGGPlot2, add = ac)
    checkmate::reportAssertions(ac)
    
    if (is.null(analysis))
        annTable <- annotations(obj)[[groupName]]
    else
        annTable <- annotations(obj, TRUE)[[analysis, groupName]]
    
    if (is.null(annTable) || nrow(annTable) == 0 || index > nrow(annTable))
        return(NULL)
    
    mcn <- mergedConsensusNames(obj, FALSE)
    
    if (normalizeScores != "none")
        annTable <- normalizeAnnScores(annTable, annScoreNames(obj, TRUE), obj@scoreRanges[[groupName]], mcn,
                                       normalizeScores == "minmax", excludeNormScores)
    
    scoreCols <- getAllMergedConsCols(annScoreNames(obj, FALSE), names(annTable), mcn)

    makeScoresPlot(annTable[index, scoreCols, with = FALSE], mcn, useGGPlot2)
})

setMethod("plotScoresHash", "formulas", function(obj, index, groupName, analysis = NULL, normalizeScores = "max",
                                                 excludeNormScores = defaultExclNormScores(obj),
                                                 useGGPlot2 = FALSE)
{
    if (is.null(analysis))
        annTable <- annotations(obj)[[groupName]]
    else
        annTable <- annotations(obj, TRUE)[[analysis, groupName]]
    if (is.null(annTable) || nrow(annTable) == 0 || index > nrow(annTable))
        annTable <- NULL
    else if (normalizeScores == "none")
        annTable <- annTable[index]
    
    return(makeHash(index, annTable, normalizeScores, excludeNormScores, useGGPlot2))
})

#' @templateVar what formulas
#' @template consensus-form_comp
#'
#' @templateVar what formulas
#' @template consensus-common-args
#'
#' @return \code{consensus} returns a \code{formulas} object that is produced by
#'   merging results from multiple \code{formulas} objects.
#'
#' @export
setMethod("consensus", "formulas", function(obj, ..., absMinAbundance = NULL, relMinAbundance = NULL,
                                            uniqueFrom = NULL, uniqueOuter = FALSE, rankWeights = 1, labels = NULL)
{
    # NOTE: keep args in sync with formulasSet method
    
    allFormulas <- c(list(obj), list(...))
    
    ac <- checkmate::makeAssertCollection()
    checkmate::assertList(allFormulas, types = "formulas", min.len = 2, any.missing = FALSE,
                          unique = TRUE, .var.name = "...", add = ac)
    checkmate::assertNumber(rankWeights, lower = 0, finite = TRUE, add = ac)
    checkmate::assertCharacter(labels, min.chars = 1, len = length(allFormulas), null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)
    
    labels <- prepareConsensusLabels(obj, ..., labels = labels)

    assertConsCommonArgs(absMinAbundance, relMinAbundance, uniqueFrom, uniqueOuter, labels)
    
    cons <- doFeatAnnConsensus(obj, ..., rankWeights = rankWeights, annNames = labels,
                               uniqueCols = c("neutral_formula", "error", "error_median", "dbe", "neutralMass"))
    
    ret <- formulasConsensus(groupAnnotations = cons, featureFormulas = list(),
                             algorithm = paste0(unique(sapply(allFormulas, algorithm)), collapse = ","),
                             mergedConsensusNames = labels)
    
    ret <- filterFeatAnnConsensus(ret, absMinAbundance, relMinAbundance, uniqueFrom, uniqueOuter, FALSE)
    
    return(ret)
})


#' @templateVar func generateFormulas
#' @templateVar what generate formulae
#' @templateVar ex1 generateFormulasDA
#' @templateVar ex2 generateFormulasGenForm
#' @templateVar algos bruker,genform,sirius
#' @template generic-algo
#'
#' @param ... Any parameters to be passed to the selected formula generation
#'   algorithm.
#'
#' @rdname formula-generation
#' @aliases generateFormulas
#' @export
setMethod("generateFormulas", "featureGroups", function(fGroups, MSPeakLists, algorithm, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertChoice(algorithm, c("bruker", "genform", "sirius"))
    checkmate::reportAssertions(ac)
    
    f <- switch(algorithm,
                bruker = generateFormulasDA,
                genform = generateFormulasGenForm,
                sirius = generateFormulasSIRIUS)
    
    f(fGroups, MSPeakLists, ...)
})
