% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R, R/components.R, R/components-camera.R,
%   R/components-cliquems.R, R/components-intclust.R, R/components-nontarget.R,
%   R/components-openms.R, R/components-ramclustr.R, R/components-specclust.R,
%   R/components-tps.R
\docType{class}
\name{component-generation}
\alias{component-generation}
\alias{generateComponents,featureGroups-method}
\alias{generateComponents}
\alias{generateComponentsCAMERA,featureGroups-method}
\alias{generateComponentsCliqueMS,featureGroups-method}
\alias{generateComponentsCliqueMS,featureGroupsSet-method}
\alias{generateComponentsIntClust,featureGroups-method}
\alias{generateComponentsNontarget,featureGroups-method}
\alias{componentsOpenMS-class}
\alias{componentsOpenMS}
\alias{generateComponentsOpenMS,featureGroups-method}
\alias{generateComponentsOpenMS,featureGroupsSet-method}
\alias{defaultOpenMSAdducts}
\alias{generateComponentsRAMClustR,featureGroups-method}
\alias{generateComponentsSpecClust,featureGroups-method}
\alias{generateComponentsTPs,featureGroups-method}
\title{Grouping feature groups in components}
\usage{
\S4method{generateComponents}{featureGroups}(fGroups, algorithm, ...)

\S4method{generateComponentsCAMERA}{featureGroups}(
  fGroups,
  ionization,
  onlyIsotopes = FALSE,
  minSize = 2,
  relMinReplicates = 0.5,
  extraOpts = NULL
)

\S4method{generateComponentsCliqueMS}{featureGroups}(
  fGroups,
  ionization,
  maxCharge = 1,
  maxGrade = 2,
  ppm = 10,
  adductInfo = NULL,
  absMzDev = 0.005,
  minSize = 2,
  relMinAdductAbundance = 0.75,
  adductConflictsUsePref = TRUE,
  NMConflicts = c("preferential", "mostAbundant", "mostIntense"),
  prefAdducts = c("[M+H]+", "[M-H]-"),
  extraOptsCli = NULL,
  extraOptsIso = NULL,
  extraOptsAnn = NULL,
  parallel = TRUE
)

\S4method{generateComponentsCliqueMS}{featureGroupsSet}(fGroups, ...)

\S4method{generateComponentsIntClust}{featureGroups}(
  fGroups,
  method = "complete",
  metric = "euclidean",
  normFunc = max,
  average = TRUE,
  maxTreeHeight = 1,
  deepSplit = TRUE,
  minModuleSize = 1
)

\S4method{generateComponentsNontarget}{featureGroups}(
  fGroups,
  ionization,
  rtRange = c(-120, 120),
  mzRange = c(5, 120),
  elements = c("C", "H", "O"),
  rtDev = 30,
  absMzDev = 0.002,
  absMzDevLink = absMzDev * 2,
  traceHack = all(R.Version()[c("major", "minor")] >= c(3, 4)),
  ...
)

\S4method{generateComponentsOpenMS}{featureGroups}(
  fGroups,
  ionization,
  chargeMin = 1,
  chargeMax = 1,
  chargeSpan = 3,
  qTry = "heuristic",
  potentialAdducts = defaultOpenMSAdducts(ionization),
  minRTOverlap = 0.66,
  retWindow = 1,
  absMzDev = 0.005,
  minSize = 2,
  relMinAdductAbundance = 0.75,
  adductConflictsUsePref = TRUE,
  NMConflicts = c("preferential", "mostAbundant", "mostIntense"),
  prefAdducts = c("[M+H]+", "[M-H]-"),
  extraOpts = NULL
)

\S4method{generateComponentsOpenMS}{featureGroupsSet}(fGroups, ...)

defaultOpenMSAdducts(ionization)

\S4method{generateComponentsRAMClustR}{featureGroups}(
  fGroups,
  st = NULL,
  sr = NULL,
  maxt = 12,
  hmax = 0.3,
  normalize = "TIC",
  ionization,
  absMzDev = 0.002,
  relMzDev = 5,
  minSize = 2,
  relMinReplicates = 0.5,
  RCExperimentVals = list(design = list(platform = "LC-MS"), instrument =
    list(ionization = ionization, MSlevs = 1)),
  extraOptsRC = NULL,
  extraOptsFM = NULL
)

\S4method{generateComponentsSpecClust}{featureGroups}(
  fGroups,
  MSPeakLists,
  method = "complete",
  specSimParams = getDefSpecSimParams(),
  maxTreeHeight = 1,
  deepSplit = TRUE,
  minModuleSize = 1
)

\S4method{generateComponentsTPs}{featureGroups}(
  fGroups,
  fGroupsTPs = fGroups,
  ignoreParents = FALSE,
  TPs = NULL,
  MSPeakLists = NULL,
  formulas = NULL,
  compounds = NULL,
  minRTDiff = 20,
  specSimParams = getDefSpecSimParams()
)
}
\arguments{
\item{fGroups}{\code{\link{featureGroups}} object for which components should be generated.

  For \code{generateComponentsTPs}: also see the \code{fGroupsTPs} argument.}

\item{algorithm}{A character string describing the algorithm that should be
used: \code{"ramclustr"}, \code{"camera"}, \code{"nontarget"}, \code{"intclust"}, \code{"openms"}, \code{"cliquems"}, \code{"specclust"}, \code{"tp"}}

\item{...}{Any parameters to be passed to the selected component generation
algorithm.}

\item{ionization}{Which ionization polarity was used to generate the data: should be \code{"positive"} or
\code{"negative"}.}

\item{onlyIsotopes}{Logical value. If \code{TRUE} only isotopes are
considered when generating components (faster). Corresponds to \code{quick}
argument of \code{\link[CAMERA:annotate-methods]{CAMERA::annotate}}.}

\item{minSize}{The minimum size of a component. Smaller components than this size will be removed. For
\code{RAMClustR}: sets the \code{minModuleSize} argument to \code{\link[RAMClustR]{ramclustR}}. See note below.}

\item{relMinReplicates}{Feature groups within a component are only kept when they contain data for at least this
(relative) amount of replicate analyses. For instance, \samp{0.5} means that at least half of the replicates should
contain data for a particular feature group in a component. In this calculation replicates that are fully absent
within a component are not taken in to account. See note below.}

\item{extraOpts}{Named character vector with extra arguments directly passed to
\code{\link[CAMERA:annotate-methods]{CAMERA::annotate}} (\code{generateComponentsCAMERA}) or as extra command line
parameters to \command{MetaboliteAdductDecharger} (\code{generateComponentsCAMERA}). Set to \code{NULL} to ignore.}

\item{maxCharge, maxGrade, ppm}{Arguments passed to \code{\link[cliqueMS:getIsotopes]{cliqueMS::getIsotopes}} and/or
\code{\link[cliqueMS:getAnnotation]{cliqueMS::getAnnotation}}.}

\item{adductInfo}{Sets the \code{adinfo} argument to \code{\link[cliqueMS:getAnnotation]{cliqueMS::getAnnotation}}.
If \code{NULL} then the default adduct information from \pkg{cliqueMS} is used (\emph{i.e.} the
\code{positive.adinfo}/\code{negative.adinfo} package datasets).}

\item{relMinAdductAbundance}{The minimum relative abundance (\samp{0-1}) that an adduct should be assigned to
features within the same feature group. See the \verb{Feature components} section for more details.}

\item{adductConflictsUsePref}{If set to \code{TRUE}, and not all adduct assigments to the features within a feature
group are equal and at least one of those adducts is a preferential adduct (\code{prefAdducts} argument), then only
the features with (the lowest ranked) preferential adduct are considered. In all other cases or when
\code{adductConflictsUsePref=FALSE} only features with the most frequently assigned adduct is considered. See the
\verb{Feature components} section for more details.}

\item{NMConflicts}{The strategies to employ when not all neutral masses within a component are equal. Valid options
are: \code{"preferential"}, \code{"mostAbundant"} and \code{"mostIntense"}. Multiple strategies are possible, and
will be executed in the given order until one succeeds. See the \verb{Feature components} section for more details.}

\item{prefAdducts}{A \code{character} vector with one or more \emph{preferential adducts}. See the \verb{Feature
components} section for more details.}

\item{extraOptsCli, extraOptsIso, extraOptsAnn}{Named \code{list} with further arguments to be passed to
\code{\link[cliqueMS:getCliques]{cliqueMS::getCliques}}, \code{\link[cliqueMS:getIsotopes]{cliqueMS::getIsotopes}}
and \code{\link[cliqueMS:getAnnotation]{cliqueMS::getAnnotation}}, respectively. Set to \code{NULL} to ignore.}

\item{method}{Clustering method that should be applied (passed to
\code{\link[hclust:fastcluster]{fastcluster::hclust}}).}

\item{metric}{Distance metric used to calculate the distance matrix (passed to \code{\link{daisy}}).}

\item{normFunc, average}{Passed to \code{\link[=as.data.table,featureGroups-method]{as.data.table}} to perform
normalization and averaging of data.}

\item{maxTreeHeight, deepSplit, minModuleSize}{Arguments used by
\code{\link{cutreeDynamicTree}}.}

\item{rtRange}{A numeric vector containing the minimum and maximum retention
time (in seconds) between homologues. Series are always considered from low
to high \emph{m/z}, thus, a negative minimum retention time allows
detection of homologous series with increasing \emph{m/z} and decreasing
retention times. These values set the \code{minrt} and \code{maxrt}
arguments of \code{\link{homol.search}}.}

\item{mzRange}{A numeric vector specifying the minimum and maximum \emph{m/z}
increment of a homologous series. Sets the \code{minmz} and \code{maxmz}
arguments of \code{\link{homol.search}}.}

\item{elements}{A character vector with elements to be considered for
detection of repeating units. Sets the \code{elements} argument of
\code{\link{homol.search}} function.}

\item{rtDev, absMzDev, relMzDev}{Maximum deviation for retention time or absolute/relative \emph{m/z}.

  For \code{generateComponentsRAMClustR}: Sets the \code{mzabs.error} and \code{ppm.error} arguments to
  \code{\link[RAMClustR]{do.findmain}}.

  For \code{generateComponentsNontarget}: Sets the \code{rttol} and \code{mztol} arguments of
  \code{\link{homol.search}}.

  For \code{generateComponentsOpenMS}: Sets the \command{algorithm:MetaboliteFeatureDeconvolution:mass_max_diff}
  option.}

\item{absMzDevLink}{Maximum absolute \emph{m/z} deviation when linking
series. This should usually be a bit higher than \code{absMzDev} to ensure
proper linkage.}

\item{traceHack}{Currently \code{\link{homol.search}} does not work with \R
\samp{>3.3.3}. This flag, which is enabled by default on these R versions,
implements a (messy) workaround
(\href{https://github.com/blosloos/nontarget/issues/6}{more details here}).}

\item{chargeMin, chargeMax}{The minimum/maximum charge to consider. Corresponds to the
\command{algorithm:MetaboliteFeatureDeconvolution:charge_min}/\command{algorithm:MetaboliteFeatureDeconvolution:charge_min}
 options.}

\item{chargeSpan}{The maximum charge span for a single analyte. Corresponds to
\command{algorithm:MetaboliteFeatureDeconvolution:charge_span_max}.}

\item{qTry}{Sets how charges are determined. Corresponds to \command{algorithm:MetaboliteFeatureDeconvolution:q_try}.
Valid options are \code{"heuristic"} and \code{"all"} (the \code{"feature"} option from \command{OpenMS} is
currently not supported).}

\item{potentialAdducts}{The adducts to consider. Should be a \code{numeric} vector with probabilities for each
adduct, \emph{e.g.} \code{potentialAdducts=c("[M+H]+" = 0.8, "[M+Na]+" = 0.2)}. Note that the sum of probabilities
should always be \samp{1}. Furthermore, note that additions of multiple adducts should be controlled by the
\code{chargeMin}/\code{chargeMax} arguments (and \emph{not} with \code{potentialAdducts}), \emph{e.g.} if
\code{chargeMax=2} then both \code{[M+H]+} and \code{[2M+H]2+} may be considered. Please see the
\command{algorithm:MetaboliteFeatureDeconvolution:potential_adducts} option of
\href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/UTILS_MetaboliteAdductDecharger.html}{MetaboliteAdductDecharger}
 for more details. The defaults adducts to consider in \pkg{patRoon} (which are \emph{not} the same as
\command{OpenMS}) can be ontained with \code{defaultOpenMSAdducts}.}

\item{minRTOverlap, retWindow}{Sets feature retention tolerances when grouping features. Sets the
\command{"algorithm:MetaboliteFeatureDeconvolution:retention_max_diff"} and
\command{algorithm:MetaboliteFeatureDeconvolution:min_rt_overlap} options.}

\item{st, sr, maxt, hmax, normalize}{Arguments to tune the behaviour of feature
group clustering. See their documentation from \code{\link[RAMClustR]{ramclustR}}.
When \code{st} is \code{NULL} it will be automatically calculated as the
half of the median for all chromatographic peak widths.}

\item{RCExperimentVals}{A named \code{list} containing two more \code{list}s:
\code{design} and \code{instrument}. These are used to construct the
\code{ExpDes} argument passed to \code{\link[RAMClustR]{ramclustR}}.}

\item{extraOptsRC, extraOptsFM}{Named \code{list} with further arguments to be
passed to \code{\link[RAMClustR]{ramclustR}} and \code{\link[RAMClustR]{do.findmain}}.
Set to \code{NULL} to ignore.}

\item{MSPeakLists}{The \code{\link{MSPeakLists}} object for the given feature groups that should be used for MS
spectral similarity calculations. For \code{generateComponentsTPs} it can be \code{NULL}, in which case no
calculations are performed.}

\item{specSimParams}{A named \code{list} with parameters that influence the calculation of MS spectra similarities.
See the \link[=specSimParams]{spectral similarity parameters} documentation for more details.}

\item{fGroupsTPs}{A \code{\link{featureGroups}} object containing the feature groups that are expected to be
transformation products. If a distinction between parents and TPs is not yet known, \code{fGroupsTPs} should equal
the \code{fGroups} argument. Otherwise, \code{fGroups} should only contain the parent feature groups, and both
\code{fGroups} and \code{fGroupsTPs} \emph{must} be a subset of the same \code{\link{featureGroups}} object.}

\item{ignoreParents}{If \code{TRUE} then feature groups present in both \code{fGroups} and \code{fGroupsTPs} are not
considered as TPs.}

\item{TPs}{A \code{\link{transformationProducts}} object. Set to \code{NULL} to perform linking without this data.}

\item{formulas, compounds}{A \code{\link{formulas}}/\code{\link{compounds}} object to calculate annotation
similarities between parents and TPs. If \code{NULL} then this data is not calculated. For more details see the
\verb{Linking parents and transformation products} section below.}

\item{minRTDiff}{Minimum retention time difference between the parent and a TP to determine whether a TP elutes
prior/after the parent (to calculate \code{retDir} values, see Details in \link{componentsTPs}))}
}
\value{
A \code{\link{components}} (derived) object containing all generated components.

  The algorithms based on 'feature components' return a \code{\link{componentsFeatures}} derived object.

  \code{generateComponentsIntClust} and \code{generateComponentsSpecClust} return objects derived from
  \code{\link{componentsSpecClust}}.
  
  \code{generateComponentsTPs} returns objects derived from \code{\link{componentsTPs}}.
}
\description{
Functionality to automatically group related feature groups (\emph{e.g.} isotopes, adducts and homologues) to assist
and simplify compound annotation.
}
\details{
Several algorithms are provided to group feature groups that are related in some (chemical) way to each other. These
components generally include adducts, isotopes, in-source fragments and homologues. The linking of this data is
generally useful to provide more information for compound annotation and reduce the data size and thus complexity.

\code{generateComponents} is a generic function that will generate components using one of the supported algorithms. The actual
  functionality is provided by algorithm specific functions such as \code{generateComponentsRAMClustR} and \code{generateComponentsNontarget}. While these
  functions may be called directly, \code{generateComponents} provides a generic interface and is therefore usually preferred.

\code{generateComponentsCAMERA} provides an interface to
  \href{https://bioconductor.org/packages/release/bioc/html/CAMERA.html}{CAMERA}
   which is used to generate components from known adducts, isotopes and
  in-source fragments. The specified \code{featureGroups} object is
  automatically converted to an \code{\link{xcmsSet}} object using
  \code{\link{getXCMSSet}}.

\code{generateComponentsCliqueMS} uses \href{https://github.com/osenan/cliqueMS}{cliqueMS} to generate
  components using the \code{\link[cliqueMS:getCliques]{cliqueMS::getCliques}} function. The grouping of features in
  each component ('clique') is based on high similarity of chromatographic elution profiles. All features in each
  component are then annotated with the \code{\link[cliqueMS:getIsotopes]{cliqueMS::getIsotopes}} and
  \code{\link[cliqueMS:getAnnotation]{cliqueMS::getAnnotation}} functions.

\code{generateComponentsIntClust} generates components based on intensity profiles of feature groups.
  Hierarchical clustering is performed on normalized (and optionally replicate averaged) intensity data and the
  resulting dendrogram is automatically cut with \code{\link{cutreeDynamicTree}}. The distance matrix is calculated
  with \code{\link{daisy}} and clustering is performed with \code{\link[hclust:fastcluster]{fastcluster::hclust}}.
  The clustering of the resulting components can be further visualized and modified using the methods defined for
  \code{\link{componentsIntClust}}.

\code{generateComponentsNontarget} uses
  \href{https://cran.r-project.org/web/packages/nontarget/index.html}{the
  nontarget R package} to generate components by unsupervised detection of
  homologous series. In the first step the \code{\link{homol.search}}
  function is used to detect all homologues within each replicate group
  (analyses within each replicate group are averaged prior to detection).
  Then, homologous series across replicate groups are merged in case of full
  overlap or when merging of partial overlapping series causes no conflicts.

\code{generateComponentsOpenMS} uses the
  \href{https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/UTILS_MetaboliteAdductDecharger.html}{MetaboliteAdductDecharger}
   utility (see \url{http://www.openms.de}) to generate components. Features that show highly similar chromatographic
  elution profiles are grouped, and subsequently annotated with their adducts.

\code{defaultOpenMSAdducts} returns the default adducts and their probabilities when the OpenMS algorithm is
  used for componentization. See the \code{potentialAdducts} argument for more details.

\code{generateComponentsRAMClustR} uses
  \href{https://github.com/cbroeckl/RAMClustR}{RAMClustR} to generate
  components from feature groups which follow similar chromatographic
  retention profiles, but are not necessarily restricted to known rules
  (\emph{e.g.} adducts or isotopes). This method uses the
  \code{\link[RAMClustR]{ramclustR}} functions for generating the components, whereas
  \code{\link[RAMClustR]{do.findmain}} is used for annotation.

\code{generateComponentsSpecClust} generates components based on MS/MS similarity between feature groups.
  The similarities are converted to a distance matrix and used as input for hierarchical clustering, and the
  resulting dendrogram is automatically cut with \code{\link{cutreeDynamicTree}}. The clustering is performed with
  \code{\link[hclust:fastcluster]{fastcluster::hclust}}.

\code{generateComponentsTPs} generates components by linking feature groups of transformation products and
  their parents. Moreover, this method typically employs data from \link[=TP-generation]{generated transformation
  products} to find parents and their TPs. However, this data is not necessary, and components can also be made based
  on MS/MS similarity and/or other annotation similarities between the parent and its TPs. For more details see the
  \verb{Linking parents and transformation products} section below.
}
\note{
For \code{generateComponentsCAMERA} and \code{generateComponentsRAMClustR}: the \code{minSize} and
  \code{relMinReplicates} arguments provide additional filtering functionality not provided by \pkg{CAMERA} or
  \pkg{RAMClustR} (except \code{minSize}). Note that these filters are enabled by default, hence, final results may
  be different than what CAMERA/RAMClustR normally would return.

The \code{shift} parameter of \code{specSimParams} is ignored by \code{generateComponentsTPs}, since it always
  calculates similarities with all supported options.
}
\section{Feature components}{
 Components resulting from \code{generateComponentsCliqueMS} and
  \code{generateComponentsOpenMS} are based on so called \emph{feature components}. Unlike other algorithms,
  components are first made on a feature level (per analysis), instead of for complete feature groups. In the final
  step the feature components are converted to 'regular' components by employing a consensus approach with the
  following steps:

  \enumerate{

  \item If an adduct assigned to a feature only occurs as a minority compared to other adduct assigments within the
  same feature group, it is considered as an outlier and removed accordingly (controlled by the
  \code{relMinAdductAbundance} argument).

  \item For features within a feature group, only keep their adduct assignment if it occurs as the most frequent or
  is preferential (controlled by \code{adductConflictsUsePref} and \code{prefAdducts} arguments).

  \item Components are made by combining the feature groups for which at least one of their features are jointly
  present in the same feature component.

  \item Conflicts of neutral mass assignments within a component (\emph{i.e.} not all are the same) are dealt with.
  Firstly, all feature groups with an unknown neutral mass are split in another component. Then, if conflicts still
  occur, the feature groups with similar neutral mass (determined by \code{absMzDev} argument) are grouped. Depending
  on the \code{NMConflicts} argument, the group with one or more preferential adduct(s) or that is the largest or
  most intense is selected, whereas others are removed from the component. In case multiple groups contain
  preferential adducts, and \samp{>1} preferential adducts are available, the group with the adduct that matches
  first in \code{prefAdducts} 'wins'. In case of ties, one of the next strategies in \code{NMConflicts} is tried.

  \item If a feature group occurs in multiple components it will be removed completely.

  \item the \code{minSize} filter is applied.

  }
}

\section{Linking parents and transformation products}{
 With \code{generateComponentsTPs}, each component consists of
  feature groups that are considered to be transformation products for one parent (the parent that 'belongs' to the
  component can be retrieved with the \code{\link{componentInfo}} method). The parent feature groups are taken from
  the \code{fGroups} parameter, while the feature groups for TPs are taken from \code{fGroupsTPs}. If a feature group
  occurs in both variables, it may therefore be considered as both a parent or TP.

  If transformation product data is given, \emph{i.e.} the \code{TPs} argument is set, then a suspect screening of
  the TPs must be performed in advance (see \code{\link{screenSuspects}} and \code{\link{convertToSuspects}} to
  create the suspect list). Furthermore, if TPs were generated with \code{\link{generateTPsBioTransformer}} or
  \code{\link{generateTPsLibrary}} then the suspect screening must also include the parents (\emph{i.e.} by setting
  \code{includeParents=TRUE} when calling \code{convertToSuspects}). The suspect screening is necessary for the
  componentization algorithm to map the feature groups of the parent or TP. If the the suspect screening yields
  multiple TP hits, all will be reported. Similarly, if the suspect screening contains multiple hits for a parent, a
  component is made for each of the parent hits.

  In case no transformation product data is provided (\code{TPs=NULL}), the componentization algorithm simply assumes
  that each feature group from \code{fGroupsTPs} is a potential TP for every parent feature group in \code{fGroups}.
  For this reason, it is highly recommended to specify which feature groups are parents/TPs (see the
  \code{fGroupsTPs} argument description above) and \emph{crucial} that the data is post-processed, for instance by
  only retaining TPs that have high annotation similarity with their parents (see the
  \code{\link[=filter,componentsTPs-method]{filter}} method for \code{\link{componentsTPs}}).

  An typical way to distinguish which feature groups are parents or TPs from two different (groups of) samples is by
  calculating Fold Changes (see the \code{\link[=as.data.table,featureGroups-method]{as.data.table}} method for
  feature groups and \code{\link{plotVolcano}}). Of course, other statistical techniques from \R are also suitable.

  During componentization, several characteristics are calculated which may be useful for post-processing: \itemize{

  \item \code{specSimilarity}: the MS/MS spectral similarity between the feature groups of the TP and its parent
  (\samp{0-1}).

  \item \code{specSimilarityPrec},\code{specSimilarityBoth}: as \code{specSimilarity}, but calculated with binned
  data using the \code{"precursor"} and \code{"both"} method, respectively (see \link[=specSimParams]{MS spectral
  similarity parameters} for more details).

  \item \code{fragmentMatches} The number of MS/MS fragment formula annotations that overlap between the TP and
  parent. If both the \code{formulas} and \code{compounds} arguments are specified then the annotation data is pooled
  prior to calculation. Note that only unique matches are counted. Furthermore, note that annotations from \emph{all}
  candidates are considered, even if the formula/structure of the parent/TP is known. Hence, \code{fragMatches} is
  mainly useful when little or no chemical information is known on the parents/TPs, \emph{i.e.}, when \code{TPs=NULL}
  or originates from \code{\link{generateTPsLogic}}. Since annotations for all candidates are used, it is highly
  recommended that the annotation objects are first processed with the \code{\link{filter}} method, for instance, to
  select only the top ranked candidates.

  \item \code{neutralLossMatches} As \code{fragmentMatches}, but counting overlapping neutral loss formulae.

  \item \code{retDir} The retention time direction of the TP relative to its parent. See Details in
  \link{componentsTPs}. If TP data was specified, the expected direction is stored in \code{TP_retDir}.

  \item \code{retDiff},\code{mzDiff},\code{formulaDiff} The retention time, \emph{m/z} and formula difference between
  the parent and TP (latter only available if data TP formula is available).

  }
}

\references{
\insertRef{Scholle2018}{patRoon} \cr\cr \addCitations{fastcluster}{1}

\addCitations{CAMERA}{1}

\insertRef{Senan2019}{patRoon}

\addCitations{nontarget}{1} \cr\cr \addCitations{enviPat}{1}

\insertRef{Bielow2010}{patRoon}

\insertRef{Broeckling2013}{patRoon} \cr\cr
  \insertRef{Broeckling2014}{patRoon}
}
\author{
Rick Helmus <\email{r.helmus@uva.nl}> and Bas van de Velde (major contributions to spectral binning and
  similarity calculation).
}
